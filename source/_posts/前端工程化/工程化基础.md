---
title: 前端工程化基础
date: 2023-12-11
tags: 
  - 前端
  - 工程化
categories: 前端
keywords: 
  - 工程化
---

### 脚手架

#### CLI
命令行工具，是用户与脚手架工具进行交互的入口。
- **定义**：是一个命令行程序。（比如`vue create` 或 `npx create-react-app`）
- **作用**：负责接受用户输入的命令和参数，执行创建项目的逻辑。
- **功能**：根据你的选择，动态地从仓库拉取文件，并修改其中的配置。

**CLI管理模板的机制**
管理多个不同的模板
1. 独立的Git仓库
2. 独立的NPM包
> 核心思想：解耦。把项目初始化结构的配置（Boilerplate）与创建项目的工具（CLI）分开

**命令行交互**
**`Inquirer.js` 的作用：** 它抽象了底层终端的输入输出，让我们能轻松地创建用户友好的提示（Prompts），从而根据用户的选择动态生成项目配置。

#### Boilerplate
脚手架工作的内容基础（预设的模板）
- **定义**：一个预设好、可复用的项目模板
- **作用**：包含了一个开箱即用的项目所需的一切，例如
	- 文件结构：`src`、`plugins`等结构
	- 基础代码：`App.vue`或`index.js`这样的文件
	- 工程化配置：ESlint规则、webpack/vite构建配置、TypeScript配置文件等
- **功能**：项目规范化的体现，确保所有新项目都遵循团队设定的最佳实践。


#### 工程价值
实现**一致性**和**可维护性**
- 项目规范化
	- 一致的技术选型
	- 统一的代码风格
	- 标准化目录结构
- 降低维护成本
	- 减少重复劳动
	- 集中化配置更新

---

### 包管理

| 特性     | NPM                                  | Yarn                                           | PNPM                                                                                   |
| -------- | ------------------------------------ | ---------------------------------------------- | -------------------------------------------------------------------------------------- |
| 诞生背景 | Node.js默认自带                      | Facebook创建，为了解决**性能**和**安全性**问题 | 专注于**效率**和**磁盘空间**优化                                                       |
| 依赖机构 | 扁平化，以解决Windows 路径过长的问题 | 扁平化，类似npm3+                              | 内容可寻址存储。使用符号链接创建依赖                                                   |
| 安装速度 | 较慢，新版本已经优化很多             | 较快，有并行安装和缓存机制                     | 最快。所有模块只安装一次，通过链接引用                                                 |
| 磁盘空间 | 占用空间大，每个项目都有完整的副本。 | 占用空间较大。                                 | 最节省，模块只在磁盘上存储一次，极大地节省了空间。                                     |
| 幽灵依赖 | 扁平化结构可能导致**幽灵依赖**       | 扁平化结构可能导致**幽灵依赖**                 | 符号链接结构严格限制了项目中只能访问`package.json`中声明的依赖，有效解决了**幽灵依赖** |

**深入pnpm的优势**
`pnpm`通过独特的符号链接机制，解决了`npm`和`yarn`在磁盘空间和幽灵依赖的痛点。
- 符号链接工作原理：当你执行`pnpm install`的时候，它在项目`node_modules`目录下创建的不是实际文件，而是指向一个**全局唯一存储位置**的符号链接。这样，10个项目如果都依赖同一个版本的 React，磁盘上只会存一份 React 的代码。

---
### 本地开发

| 知识点     | 核心作用                                                                                                           | 目的                                                 |
| ---------- | ------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------- |
| Dev-Server | **运行环境**：一个简易的本地HTTP服务器，用于承载、编译并实时运行你提供的前端代码。                                 | 提供一个隔离、高效的沙盒环境，支持实时编译和HMR。    |
| Hot-Reload | **状态保持**：在不刷新整个页面的前提下，替换程序中被修改的模块                                                     | 极大的加快开发速度，并保留应用程序的当前状态。       |
| Mock       | **前后端解耦**：在后端API未完成时，模拟或拦截API请求并返回预设的假数据。                                           | 确保前端开发不受后端进度影响，可以独立、快速地进行。 |
| Proxy      | **跨域解决**：将本地开发服务器（例如：`localhost：8000`）的API转发到真实的后端服务器（例如：`api.production.com`） | 解决浏览器同源策略导致的**CORS**跨域问题             |

---
### 构建工具


| 工具     | 类型       | 核心机制                                                                                   | 主要优势                                                                   |
| -------- | ---------- | ------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------- |
| Webpack  | 打包器     | 依赖图谱：将一切视为模块，从入口开始构建复杂的依赖图，进行打包。                           | **成熟**、**功能强大**：插件生态极度丰富，适用于各种复杂的生产环境需求。   |
| Gulp     | 任务运行器 | 流式API：基于Node.js Streams，通过管道将文件依次传递给不同的任务插件进行处理。             | 自动化：非常适合执行重复性任务，如文件复制、图片压缩、Saas编译等。         |
| Vite     | 构建构建   | ES Modules + 预构建：开发环境基于浏览器的原生ESM，仅在需要时编译；生产环境使用Rollup打包。 | 极速：开发启动和热更新速度远超Webpack，极大提升了开发效率。                |
| Snowpack | 构建工具   | 原生ESM：率先利用原生 ESM 启动DEV Server，实现按需编译。                                   | 按需编译：彻底打破了传统打包模式，提高了开发速度（但目前Vite社区更有优势） |
**深入分析：Webpack和Vite**

| **方面**             | **Webpack**                                  | **Vite**                                                |
| -------------------- | -------------------------------------------- | ------------------------------------------------------- |
| **开发环境启动速度** | 慢。必须先完整扫描和打包所有模块。           | 极快。利用浏览器原生 ESM，无需打包，按需加载。          |
| **热更新（HMR）**    | 较慢。当文件修改时，需要重新打包整个模块链。 | 极快。HMR 更新路径在原生 ESM 中，速度不受应用规模影响。 |
| **生产环境打包**     | 强大且可定制，但配置复杂。                   | 使用 **Rollup**，配置简单，打包结果高效。               |

---

### CI / CD

**什么是CI/CD？**
CI/CD是一套方法论和实践，旨在通过自动化，在软件开发生命周期中频繁、可靠的交互应用。
1. 持续集成（CI）
	1. 目标：快速检测Bug。每当代码合到主干（如`main`）分支时，自动触发构建（build）、运行单元测试和代码质量检查（linting）
2. 持续交付/部署（CD）
	1. 目标：可靠交付。
		1. 交付：代码通过所有测试后，自动准备好部署，等待人工审批发布。
		2. 部署：代码通过所有测试后，自动发布到生产环境，无需人工干预。


**大体流程**
- CI流程
	1. 安装依赖（`npm install`）
		1. `Lock`文件重要性。版本锁死
	2. 运行测试与质量检查
		1. 单元测试：验证最小代码单元是否按预期工作
		2. 集成测试：验证多个模块合在一起是否能够正确协作
		3. 代码校验：运行`ESLint`和`TypeScript`检查
	3. 构建最终产物（`npm build`）
		1. 编译转换
		2. 代码优化
		3. 资源处理
- CD流程
	4. 存储构建产物
		1. 原理：在CI/CD流程中，我们不会直接执行`npm run build`的那台CI机器上部署文件。原因很简单因为CI机器通常是**临时**的，一旦完成任务就会销毁。
		2. 上传与储存：将生产的`dist`文件目录中的所有文件打包成一个`.zip`文件，然后上传到一个构建产物仓库
		3. 目的：解耦**Build**和**Deploy**,避免构建机器挂了，构建产物也是安全的。
		4. 可追溯与回滚：每个构建产物都有唯一的 ID 和版本号。如果部署到生产环境后发现问题，我们可以随时从仓库中取出**前一个版本**的产物进行**快速回滚**，保证服务的稳定性。
	5. 部署到生产环境
		1. 下载产物：CD流程或部署代理从 Artifact 仓库(如S3)下载最新版本的构建产物。
		2. 环境准备：将产物解压，放置在Web服务器的特定目录下。
		3. 服务切换：需要用技术手段将用户流量从旧版本平滑切换到新版本。
			1. 滚动部署：一台一台地替换，直到所有服务器都更新完毕。（风险低，如果有问题可以随时停止替换。）
			2. 蓝绿部署：维护两套完全相同的生产环境，测试完毕后，一件将用户流量从蓝色环境切换到绿色环境。（极速切换和回滚，用户几乎察觉不到部署过程）

---

### 微前端
> 核心思想：去耦合，它将应用拆分，从而实现了 **技术选择的自由** 和 **渐进式升级**。

将一个庞大的、单一技术栈的巨石应用拆分成多个独立开发、独立部署、独立运行的小型应用，最后这些小型应用在浏览器中无缝集成。

**解决两大痛点：**
1. 组织与协作的痛点
	- 代码冲突与评审瓶颈:  所有人都在同一个巨大的代码仓库中工作。合并请求（PR）会非常多，很容易发生代码冲突（Merge Conflicts）。此外，任何修改都需要通过少数核心维护者的评审，导致**发布周期变长**，成为协作的瓶颈。
	- 责任边界模糊: 团队难以按业务线（如：支付团队、商品团队、用户中心团队）进行完全独立的开发和部署。大家都在同一个代码库里，导致**权责不清**，协作成本极高。
2. 技术与拓展的痛点
	- 技术栈锁死: 一旦选择了 React 或 Vue 的某个版本，整个应用就被“锁死”在这个技术栈上。想要升级版本或引入一个新的框架（如 Svelte）会变得极其困难和昂贵。这阻碍了团队采用新技术来提高效率。
	- 构建与部署缓慢: 即使只修改了一个小按钮的样式，也需要**重新构建和部署**整个庞大的应用。这使得 CI/CD 流程变慢，严重拖慢了反馈周期和发布频率。

**物理拆分后**
1. 明确的责任边界
	- 物理隔离即责任隔离
	- 全栈所有权
	- 结果
2. 消除协作瓶颈
	- 独立的部署周期
	- 减少代码冲突

**集成层如何实现隔离？**
微前端的集成层（通常由 `single-spa`、`Qiankun` 或 `MicroApp` 等框架实现）主要从两个方面入手：

1. CSS/样式隔离（相对简单）
	- **命名规范：** 使用 BEM 或 CSS Modules，确保组件级别的类名是唯一的。
	- **Shadow DOM：** 使用 Web Components 的 Shadow DOM 特性，为每个微应用创建一个隔离的 DOM 子树，样式完全无法泄漏到外部或从外部泄漏进来。

2. JavaScript 沙箱（JS Isolation - 技术难度高）
这是防止全局污染的核心。最流行的做法是实现一个 **JS 沙箱（Sandbox）**，让每个微应用认为自己是运行在一个**干净的、独立的 `window` 环境**中。
- 如何实现：使用 Proxy 创建代理，拦截写入，局部存储（将这个修改存储到沙箱内部的字典当中）

**核心价值观**
业务敏捷性
- 解耦组织
- 解耦技术栈
- 解耦应用
敏捷性意味着前端团队可以根据市场需求，**更快、更频繁、更可靠**地交付新功能，而不是被单一的代码库或漫长的发布周期所拖累。

**变更检测**
它让CI/CD知道哪些部分需要工作，哪些部分可以跳过。

大的代码仓库（Monorepo）
1. 物理隔离：每个微应用（如 `/cart`、`/user`）都有自己独立的文件夹，包含自己的 `package.json`、`vite.config.js` 和 CI 配置文件。
2. 变更检查：CI/CD 系统（如 GitHub Actions 或 Jenkins）在收到新的代码提交时，会先检查这次提交**修改了哪些文件**。
3. 精确执行：如果发现只有 `/cart` 文件夹下的文件发生了变化，CI/CD 就会执行一个**条件判断**：
    - **只运行** `/cart` 微应用的 `npm install`、`npm run test` 和 `npm run build`。
    - **完全跳过** `/user`、`/product` 等未修改的微应用的相关流程。

变更检测逻辑
1. 识别变更文件
	1. CI会使用git命令来比较当前分钟和目标分支之间的差异，从而获取所被修改的文件列表
2. 使用条件判断
	1. 一旦有了文件列表，就可以在CI配置文件中添加条件判断，让工作流只在特定路径下的文件被修改时执行。

---

### BFF
前端应用在尝试直接与多个后端微服务通信时，最容易出现两个核心问题。

1. 性能与”聊天“问题
	1. 痛点：如果一个页面需要聚合展示三个模块的信息，需要发出3个独立的HTTP请求。如果页面复杂，请求数量会更多。
	2. 后果：增加请求的**往返延迟**
2. 数据聚合与处理的复杂性
	1. 痛点：如果每个微服务返回的数据结构都是通用的，不一定完全匹配前端的页面需求。
	2. 后果：前端必须自己负责数据的**聚合**、**转换**和**裁剪**

**解决方案：BFF（Back end for Front end）**
专为前端应用定制的中间服务层。

解决了：
1. 减少请求次数：BFF数据聚合。
2. 数据整形：负责将转换、裁剪后的数据返回给前端。