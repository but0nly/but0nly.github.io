---
title: 跨域的解决方案
date: 2023-10-05
tags: 
 - 前端
 - 浏览器
categories: 前端
keywords: 
 - 跨域 
---

### CORS（跨域资源共享）跨域问题解决方案
让服务端明确告诉浏览器，哪些资源可以由外部访问。

**CORS**的工作原理可分为：*简易请求*和*预检请求*

##### 简易请求
何为建议请求：
1. 方法限制：`GET`、`POST`之一
2. Header限制：没有自定义`Header`
3. `Content-type`限制：只能是 `application/x-www-form-urlencoded`、`multipart/form-data` 或 `text/plain`

此时的工作流程：
1. 浏览器发出请求：浏览器像往常一样发出请求，会在`Header`中自动添加一个`origin`字段，表明当前页面的源。
2. 服务端处理请求：服务端接受请求、处理数据，并准备响应。
3. 服务端添加**CORS**响应头：在响应头中添加一个关键字段：
	- `Access-Control-Allow-Origin：<Origin>`
	- 或者`Access-Control-Allow-Origin`允许所有源访问
4. 浏览器检查：浏览器检查`Access-Control-Allow-Origin`的值
	- 如果`Origin`与之匹配，浏览器就允许JavaScript访问数据
	- 如果不匹配或者缺少该字段，浏览器就会抛出**跨域**错误，并丢弃响应数据。

##### 预检请求
不符合*简易请求*的都是*预检请求*。例如`PUT`/`DELETE`方法的请求，或者请求中包含了自定义`Header`。

工作流程：
1. 浏览器发送预检请求：在发出正式请求之前，浏览器会先自动发送一个`OPTIONS`方法的请求，这个就是*预检*，*预检*请求头中携带关键信息：
	- `Origin`：实际请求的源
	- `Access-Control-Request-Method`：实际请求的方法
	- `Access-Control-Request-Headers`：实际请求携带的自定义`Header`列表
2. 浏览器响应*预检*"：
	- `Access-Control-Allow-Origin`：允许的源
	- `Access-Control-Allow-Method`：允许的请求方法
	- `Access-Control-Allow-Headers`：允许携带的自定义`Header`列表
	- `Access-Control-Max-Age`：缓存时间，表示接下来多少秒内，对于同一个源，不需要再发送*预检*请求。
3. 浏览器判断
	- 如果*预检*通过，浏览器才会发送第二次，也就是实际请求，
	- 如果*预检*失败，浏览器就直接抛出失败，不会发送实际请求。


#### 凭证共享
默认情况下，跨域请求不会带上`Cookie`和HTTP认证信息。如果需要携带凭证，需要在客户端和服务端同时配置`credentials`。
- **客户端 (JS)**：在请求中设置 `credentials` 属性为 `include`。
- **服务器端 (响应头)**：必须设置：
    - `Access-Control-Allow-Credentials: true`
    - **注意**：一旦设置了 `Access-Control-Allow-Credentials: true`，则 **`Access-Control-Allow-Origin` 的值就不能是 `*` (星号)**，必须指定具体的源，以确保安全。


### 跨域的解决方法
最常用最安全稳定的解决方案就是：**跨域代理**，其他都是已经过时或者就是不安全不稳定。

***跨域代理（Proxy）***
核心理念就是利用同源策略只限制客户端的特性。
1. 浏览器受到同源策略的原因，不能直接访问服务器B。
2. 但是代理服务器A却不受同源策略的影响。

所以，解决办法是：我们在客户端和服务端B之前加一个代理服务器A。用于中转数据，不受同源策略影响。主要流程：
1. 客户端向*代理服务器A*发出请求。
2. *代理服务器A*收到请求后，代向*目标服务器B*发送请求。
3. *目标服务器B*收到请求后，将响应结果返回给*代理服务器A*
4. *代理服务器A*再将响应转发给客户端。

##### 实现方式
分为*开发环境*和*生产环境*

*开发环境*：
通过前端构建工具（`webpack dev server`、`vite`、`create react app`或者`Vue ClI`等等）提供的代理功能。
```json
// vue.config.js 或 webpack dev server 配置
devServer: {
  // 告诉开发服务器，将所有以 '/api' 开头的请求代理到目标服务器
  proxy: {
    '/api': {
      target: 'http://third-party-api.com', // 目标服务器地址
      changeOrigin: true, // 非常重要：将请求的 Host 字段改为目标服务器的 Host
      pathRewrite: {
        '^/api': '' // 可选：重写路径，例如将 /api/users 变为 /users
      }
    }
  }
}
```

*生产环境*
需要使用成熟的Web服务器（*Niginx*或者*Apache*等）又或是*java*/*node.js*等后端服务器作为反向代理。
```json
server {
    listen 80;
    server_name frontend.com; # 前端域名

    location /api/ {
        # 将所有 /api/ 开头的请求代理到目标服务器
        proxy_pass http://target-api.com/;
        proxy_set_header Host $host;
    }

    location / {
        # 匹配其他路径，用于提供前端静态文件
        root /path/to/frontend/dist;
        index index.html;
    }
}
```

##### 代理服务器的优劣势

| 特性     | 优势                                                         | 劣势                                 |
| -------- | ------------------------------------------------------------ | ------------------------------------ |
| *灵活性* | 几乎可以解决所有跨域问题。包括第三方API。                    | 需要配置或维护额外的代理服务器。     |
| *安全性* | 隐藏后端服务器或第三方API的真实地址。                        | 中间多了一层网络请求。略微增加延迟   |
| *控制权* | 可以对请求和响应进行拦截和修改（添加认证Header或者记录日志） | 如果配置不恰当，可能会带来安全问题。 |


### 其他跨域解决方案
- `JSONP`：利用`<script>`标签没有跨域限制的原理。
- `window.postMessge`：用于解决不同`iframe`窗口之间的通信。
- `WebSockets`：一种天然允许的全双工通信协议。