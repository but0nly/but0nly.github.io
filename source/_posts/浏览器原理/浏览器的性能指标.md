---
title: 浏览器的性能指标
date: 2023-10-07
tags: 
  - 前端
  - 浏览器
  - 性能优化
categories: 前端
keywords: 
 - 性能指标
---

浏览器性能指标主要关注**用户感知**，即用户觉得页面加载速度如何。

三个重要指标：
- ***LCP***（最大的内容绘制）：衡量页面主要内容的加载所需时间。
- ***INP***（交互到下一次绘制）：衡量网页的响应性。
- ***CLS*** (累积布局偏移)：衡量页面加载中，非预期的视觉内容移动的累积总分



### ***LCP***
***LCP***是衡量浏览器渲染*视口内可见的最大图像或者元素*所需时间。

一个优秀的LCP目标是页面加载时间在**2.5以内**。

关键渲染路径：
- **优化服务器响应时间**
- **资源加载优先级**
- **阻塞渲染的资源**

#### 优化服务器响应时间
一个关键因素**TTFB**（首次字节时间），如果跑慢了，后面的***LCP***无论如何都会收到影响

最佳**TTFB**时间是**0.8秒以内**

> **TTFB**：是衡量用户点击链接到服务器返回的第一个字节所需的时间
> 包括三个阶段：
> - 网络延迟：客户端发生请求到服务器所需时间
> - 服务器处理时间：服务器运行代码、查询数据库、生成*HTML*的时间
> - 响应时间：服务器将响应的第一个字节发送回客户端的时间

优化方案：
- 后端代码与数据库
- **内容分发网络（CDN）于边缘计算**
	- CDN的工作原理：
		1. *DNS的引导*：CDN的服务商通过特殊的DNS解析技术，引导用户的请求到**地理位置离他们最近的CDN节点**（或者Pop）
		2. *缓存检查*：最近的这个CDN节点会检查它的本地存储中是否有所请求的资源
		3. *内容交付*：
			1. *缓存命中*：如果存在这个资源，节点就会立即发送给用户。这是最快的路径，能大幅度减少***LCP***。
			2. *缓存未命中*：如果资源不在本地，就会去请求原始服务器，把响应回来的资源复制出副本存在本地，同时把资源发送给用户。
	- ==边缘计算：CDN的进阶版本==
- 缓存策略：[[HTTP 缓存]]

#### 资源加载优先级
即使**服务器响应时间**很快，浏览器在解析*HTML*时，如果不加予干预，它可能会平等的对待所有资源，或者因为遇到堵塞的*CSS*或*JS*而延后发现***LCP***元素所需的资源。

我们的目标是需要使用**预加载指令**来告诉浏览器，这个资源需要立即下载。

`Preload`
可以在*link*标签加上属性`rel=preload`，当预加载扫描器发现`Preload`后，它会立即启动对该资源的下载，并赋予**极高优先级**
有时候，存在多个**预加载资源**时，浏览器还是没办法确定哪个优先级更高，所以我们还有个更高级的用法，是在`rel=preload`的基础上再结合`fetchpriority="high"`,

> 我们可以给***LCP***元素做预加载，进而***LCP***所需时间。


#### 阻塞渲染的资源
即使服务器响应速度、LCP资源也提前加载，但是浏览器在**解析**和**渲染**过程中遇到堵塞的CSS和JS，整个页面的首次绘制仍然会被暂停。

⚠️阻塞机制
- *CSS*：CSS会暂停渲染，因为浏览器需要完整的CSSOM才开始渲染。这是因为CSS规则可以影响页面上的任何元素，所以，当浏览器遇到外部的`<link rel="stylesheet >"`标签时，它会暂停渲染，直到CSS文件下载并解析完毕。
- *JavaScript*：浏览器遇到`<script>`标签时,JS会暂停HTML解析，直到JS文件下载、解析和执行完毕，这是因为**JS有可能会改变DOM结构**

##### **关键CSS**
核心思路，只取出最关键、刚好满足首页渲染的CSS，而延迟其他非关键CSS的加载

优化技术：
- *提取关键CSS*：使用第三方工具分析并将这些关键规则提取出来，插入到`head`中的`style`标签。
	- ==需要注意，虽然这样会增加html的体积，但是正向收益还是可观的==
 - *延迟非关键的CSS*：
	 - 使用`media="print"`欺骗浏览器，让浏览器认为这个样式表只用于打印，所以下载时不阻塞渲染。
	 - 使用`rel="preload"`预加载法，不阻塞渲染，能以高优先级尽快下载资源。

**延迟JavaScript加载**
对不阻塞首次渲染的脚步，使用`async`和`defer`（依赖DOM，在`ContentDownload`之前加载），使其在后台下载，不阻塞*HTML*解析。


### ***INP***
衡量用户从交互到浏览器**绘制出视觉反馈**所需时间

一个优秀的INP时间为**200毫秒**以内，超过这个值，用户就会感觉到卡顿。

首先我们要知道INP的时间分为三个阶段：
1. **输入延迟**
	1. 用户交互（点击按钮）到出发事件函数的时间
	2. 延迟原因：会受到大型JavaScript文件加载或者执行一个耗时的函数。
2. **处理时间**（*主要*）
	1. 事件函数触发，执行的JavaScript代码的所需时间
	2. 延迟原因：JavaScript代码本身运行耗时过大，或者进行大量的DOM操作
3. **呈现延迟**
	1. 事件处理程序运行完成后，到浏览器实际绘制所需时间。
	2. 延迟原因：浏览器需要重新计算新的样式、进行布局和绘制。可能因为之前主线程的繁忙而被推迟

我们主要从影响最大的**处理时间**来优化，处理时间为什么最具影响力呢，因为在JavaScript中如果一个代码执行超过50ms，它就会被认为是**长任务**。

> 🚨瓶颈：长任务。
> 长任务运行期间，主线程完全被占用，无法执行以下操作。
> 1. 响应其他用户输入
> 2. 处理网络事件
> 3. 页面渲染

解决这个问题的核心策略是：**将长任务分解成小块，并允许主线程在小块之间“喘息”（Yielding）**。

#### 任务分解与 yielding（喘息）
使用`setTime(0)`来把长任务拆成多个短任务，运用宏任务机制来给主线程喘息的机会。
```js
function chunkedTask(items) {
  const chunkSize = 100;
  let i = 0;
  
  function processChunk() {
    // 处理 100 个项目
    for (let j = 0; j < chunkSize && i < items.length; j++, i++) {
      // 耗时操作...
    }

    if (i < items.length) {
      // 关键步骤：使用 setTimeout(0) 将剩余任务推迟到下一个事件循环周期
      setTimeout(processChunk, 0); 
    }
  }

  processChunk();
}
```
==yielding（喘息）：空出来的喘息时间，可以用于上面的*输入延迟*和*呈现延迟*两个阶段。==


#### Web Worker
*Web Worker*主要的工作原理就是将JavaScript代码放到**后台线程**中去执行，从而不影响主线程的运行。

优点：
- 非阻塞
- 响应性

缺点：
- 无法操作*DOM*

但是因为是后台线程，是一个独立的环境，所以没有办法操作*DOM*，所以只适合处理复杂的数学计算和加密解密等操作。

因为没有办法去操作*DOM*，所以Web Worker是通过**消息传递**去通知主线程：我这边数据算好了，你那边可以执行渲染操作了，
```js
// 主线程代码示例
worker.onmessage = function(event) {
  // 当 Worker 线程发送数据回来时，这个回调函数就会被触发
  const result = event.data;
  updateUI(result); // 在这里安全地更新 DOM
};
```

> **Web Worker**的消息传递，也是回调的一种，所以会加入到*Call Back Queue*中等待执行


### 昂贵的DOM操作
真正大的开销就是**重排（Layout）**；

🚨陷阱：*强制同步布局*
通常发生在*写入*完成后，再*读去*元素的属性。

解决方案：主要一个优化手段就是集中处理DOM，**读取**和**写入**操作完全分开。利用`setTime(0)`去分隔读和写，写入时不会受*强制同步布局影响*


## ***CLS***
**累积布局偏移**
衡量的是页面加载过程中，**非预期**的视觉内容移动的累积总分。

优秀的CLS总分应该**低于0.1**

分数计算公式：
$$CLS = \text{Impact Fraction} \times \text{Distance Fraction}$$
- Impact Fraction（影响分数）：布局移动后，受影响元素在视图中所占区域的比例。
- Distance Fraction（距离分数）：受影响元素在视口中移动的距离占视口尺寸的比例。

影响CLS分数的罪魁祸首有哪些：
- 没有设置尺寸的图片
- 延时加载的字体
- 动态注入的广告

#### 解决没有尺寸的媒体
`aspect-ratio：【width】/【height】`设置宽高比。让容器始终保持一个特定的宽高比。

**关键点:** 无论这个容器的宽度是多少，它的高度都会根据这个 `aspect-ratio` 自动计算并被 **锁定**。这样，即使图片文件本身还没加载完成，浏览器也已经为它预留了一个完美的矩形空间。

因为空间是预留的，所以当图片加载完成时，它只会填充这个预留空间，而**不会**向下推挤任何内容，从而**消除**了由图片加载导致的 CLS。
