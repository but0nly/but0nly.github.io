<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>but0nly&#39;blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="分享一些技术总结和想法">
<meta property="og:type" content="website">
<meta property="og:title" content="but0nly&#39;blogs">
<meta property="og:url" content="https://but0nly.github.io/index.html">
<meta property="og:site_name" content="but0nly&#39;blogs">
<meta property="og:description" content="分享一些技术总结和想法">
<meta property="og:locale">
<meta property="article:author" content="but0nly">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="but0nly'blogs" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">but0nly&#39;blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://but0nly.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-AI/关于使用cursor的一些思路" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/18/AI/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8cursor%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF/" class="article-date">
  <time class="dt-published" datetime="2025-06-17T16:00:00.000Z" itemprop="datePublished">2025-06-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/18/AI/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8cursor%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF/">关于我是用Cursor的一些思路</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>近期用 Cursor 写了几个项目，包括维护旧项目，全部没写过一行代码，通过聊天解决，工作效率至少翻 5 倍，分享几条技巧。</p>
<ol>
<li>先定规范，新项目可以输入需求文档、各种技术规范，比如通信协议等文档，全转成 markdown 格式，保存在代码库里。然后让 ai 生成架构文档。老项目直接让根据现有代码和资料生成架构文档保存起来。架构文档一定要 review ，以后都要按这个来。</li>
<li>每次聊天时，保证输入的信息能闭环，能提供详细的周边环境资料，如果有参考资料、可参考的开源项目等、一定要给他提供过去，你提供的资料越细，他实现的越好。</li>
<li>写完要让 ai review 代码，先是纵向 review ，按模块，比如一个登录流程从前端到接口到数据库再到响应格式。然后再横向 review ，比如数据库模型层和数据库表结果比对等，还可以自己判断容易出错的地方，也要让 review 。还可以参考需求文档进行 review 。</li>
<li>让 ai 自己写测试，可以是测试用例，可以是测试页面，用于方便自己点击测试等等，毕竟 ai 写个页面分分钟的事情。</li>
<li>ai 写过的代码，要 review 大架子是否合适、和需求是否有偏差，不需要 review 细节。ai 写的函数、方法等不会存在低级的逻辑 bug 。</li>
<li>改不确定的代码逻辑前，先让 AI 分析这块儿的代码，给出分析结果，如果分析结果你认为不对，提出问题点，让 ai 再复核一次，直到分析结果对了以后，再让 AI 上手改；而不是直接改。</li>
<li>如果有问题解决不了，让 AI 增加日志、然后将日志和问题现象一并交给 ai 让他再处理。99%的情况不需要自己去分析。</li>
<li>总的原则，AI 是一个局部能力很强，但是大局观差一些的小助理，所以在大方向上做好引导，就会变成一个任劳任怨、随时待命的帮手，开发啥都不是事。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://but0nly.github.io/2025/06/18/AI/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8cursor%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF/" data-id="cuid-OSWh3be6HrrJ3yXWx53-" data-title="关于我是用Cursor的一些思路" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AI/" rel="tag">AI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-问题/关于使用IndexDB的坑" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/01/18/%E9%97%AE%E9%A2%98/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8IndexDB%E7%9A%84%E5%9D%91/" class="article-date">
  <time class="dt-published" datetime="2025-01-17T16:00:00.000Z" itemprop="datePublished">2025-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/01/18/%E9%97%AE%E9%A2%98/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8IndexDB%E7%9A%84%E5%9D%91/">关于使用 IndexDB 的选型以及碰到的问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在公司内负责做一个工作流编排模块,由于存在节点过多,用户写入数据过多的场景,继而会有些用户会因为误触其他地方或者是页面刷新,导致填写了半天的数据一个没存下来.</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>由于是使用的react flow, 前端设计器的所需的数据类型为JSON, 发送给后端的也是JSON, 那这就好办了,只需要把JSON在前端缓存起来就好了.<br>我一开始是打算使用Localstorage, 后面也发现了两个不满足条件的特性,</p>
<ol>
<li>存储量小, 一个大的JSON就有可能几百kb了,存不了多少个.</li>
<li>同步模式, 会阻塞主线程.这是关键,因为需要保留上一次的操作, 频繁操作是不可避免的.</li>
</ol>
<p>然后发现浏览器还有个IndexedDB完成满足以上两个条件</p>
<ol>
<li>磁盘存储, 大小 &gt; 250mb, 够够的了.</li>
<li>异步模式,不阻塞UI,性能更好!!!</li>
</ol>
<p>所以最后果断选中了IndexedDB.<br>只需要在统一触发change的地方去存储新的JSON即可.</p>
<h3 id="开发中发现问题"><a href="#开发中发现问题" class="headerlink" title="开发中发现问题"></a>开发中发现问题</h3><p>开发中发现, 如果频繁更新IndexedDB的话会导致数据丢失，查了下原因, 原理跟SQL一样,不能频繁的更新.</p>
<h4 id="频繁更新的解决方案"><a href="#频繁更新的解决方案" class="headerlink" title="频繁更新的解决方案"></a>频繁更新的解决方案</h4><p>内存缓存 + 节流 + 批量写入</p>
<ol>
<li>创建一个JS对象，用于存储每次操作的<code>key</code>和<code>value</code>；</li>
<li>创建一个<code>autoSave</code>方法，里面就是通过创建<code>readwrite</code>事务，然后<code>put</code>新的配置信息。</li>
<li>给<code>autoSave</code>添加节流，每次触发1s后执行。</li>
<li>创建一个JS赋值函数，附带监听JS对象的赋值是否存在&#x3D;&#x3D;变化&#x3D;&#x3D;</li>
<li>如果存在变化就<code>autoSave</code></li>
<li>完美解决批量更新导致数据丢失的<em>Bug</em></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://but0nly.github.io/2025/01/18/%E9%97%AE%E9%A2%98/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8IndexDB%E7%9A%84%E5%9D%91/" data-id="cuidlaYBPjvLq42qJCpblxHLp" data-title="关于使用 IndexDB 的选型以及碰到的问题" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-想法/客户端 Mock 解决方案" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/13/%E6%83%B3%E6%B3%95/%E5%AE%A2%E6%88%B7%E7%AB%AF%20Mock%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="article-date">
  <time class="dt-published" datetime="2024-02-12T16:00:00.000Z" itemprop="datePublished">2024-02-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/">团队协作</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/13/%E6%83%B3%E6%B3%95/%E5%AE%A2%E6%88%B7%E7%AB%AF%20Mock%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">客户端 Mock 解决方案</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="轻量级浏览器端网络-Mock-工具技术方案"><a href="#轻量级浏览器端网络-Mock-工具技术方案" class="headerlink" title="轻量级浏览器端网络 Mock 工具技术方案"></a>轻量级浏览器端网络 Mock 工具技术方案</h1><h2 id="1-项目背景"><a href="#1-项目背景" class="headerlink" title="1. 项目背景"></a>1. 项目背景</h2><h3 id="1-1-现状与痛点"><a href="#1-1-现状与痛点" class="headerlink" title="1.1 现状与痛点"></a>1.1 现状与痛点</h3><p>在前后端分离的开发模式中，前端开发往往依赖后端 API 的完成度。当后端接口尚未就绪或需要模拟特定异常场景（如 500 错误、超时、特定数据结构）时，开发人员通常面临以下困境：</p>
<ul>
<li><strong>硬编码 Mock：</strong> 在业务代码中写入 Mock 数据，导致代码污染，上线前需手动清理，风险较高。</li>
<li><strong>重型工具依赖：</strong> 使用 Charles&#x2F;Fiddler 等抓包工具进行 Map Local，配置繁琐，且难以在团队间共享规则。</li>
<li><strong>本地 Node 服务器：</strong> 需要维护额外的 Mock Server，增加了开发环境的复杂度。</li>
</ul>
<h3 id="1-2-目标"><a href="#1-2-目标" class="headerlink" title="1.2 目标"></a>1.2 目标</h3><p>构建一个<strong>零侵入、可视化、轻量级</strong>的浏览器端 Mock 工具。</p>
<ul>
<li><strong>零侵入：</strong> 无需修改业务代码，通过脚本注入（Tampermonkey）即可运行。</li>
<li><strong>可视化：</strong> 提供嵌入页面的 GUI 面板，实时查看请求并编辑响应。</li>
<li><strong>隔离性：</strong> 利用 Shadow DOM 确保工具样式不污染业务页面。</li>
</ul>
<hr>
<h2 id="2-技术方案"><a href="#2-技术方案" class="headerlink" title="2. 技术方案"></a>2. 技术方案</h2><h3 id="2-1-核心架构"><a href="#2-1-核心架构" class="headerlink" title="2.1 核心架构"></a>2.1 核心架构</h3><p>本方案采用 <strong>Web Components</strong> 构建 UI，配合 <strong>Monkey Patching (猴子补丁)</strong> 技术拦截浏览器网络请求。数据持久化依赖浏览器的 <code>localStorage</code>。</p>
<table>
<thead>
<tr>
<th align="left">模块</th>
<th align="left">技术选型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>UI 视图</strong></td>
<td align="left"><strong>Web Components (Custom Elements + Shadow DOM)</strong></td>
<td align="left">实现样式完全隔离，避免 CSS 冲突；原生支持，无框架依赖。</td>
</tr>
<tr>
<td align="left"><strong>请求拦截</strong></td>
<td align="left"><strong>Monkey Patching (<code>window.fetch</code> 重写)</strong></td>
<td align="left">在 Tampermonkey 环境下，直接覆盖原生 Fetch API，实现请求的“中间人”拦截。</td>
</tr>
<tr>
<td align="left"><strong>数据存储</strong></td>
<td align="left"><strong><code>localStorage</code></strong></td>
<td align="left">存储 Mock 规则、面板位置及状态。支持按域名（Host）隔离存储。</td>
</tr>
<tr>
<td align="left"><strong>脚本注入</strong></td>
<td align="left"><strong>Tampermonkey (油猴脚本)</strong></td>
<td align="left">作为载体，将工具注入到目标网页的 <code>document-start</code> 阶段。</td>
</tr>
</tbody></table>
<h3 id="2-2-逻辑流程"><a href="#2-2-逻辑流程" class="headerlink" title="2.2 逻辑流程"></a>2.2 逻辑流程</h3><ol>
<li><strong>初始化：</strong> 脚本在页面加载最早阶段运行，覆盖 <code>window.fetch</code>，并挂载 Web Component 面板。</li>
<li><strong>请求发起：</strong> 业务代码调用 <code>fetch</code>。</li>
<li><strong>拦截判断：</strong> 拦截器归一化请求参数，查询 Mock 规则存储。<ul>
<li><strong>命中规则：</strong> 阻止真实网络请求，构造自定义 <code>Response</code> 对象返回（状态码、响应体、Header）。</li>
<li><strong>未命中规则：</strong> 放行真实请求，但劫持其响应流（Clone Response）以便在面板中记录日志。</li>
</ul>
</li>
<li><strong>UI 交互：</strong> 用户在面板中查看日志，勾选请求进行 Mock 编辑，保存后即时生效。</li>
</ol>
<hr>
<h2 id="3-详细设计与实现"><a href="#3-详细设计与实现" class="headerlink" title="3. 详细设计与实现"></a>3. 详细设计与实现</h2><h3 id="3-1-模块划分"><a href="#3-1-模块划分" class="headerlink" title="3.1 模块划分"></a>3.1 模块划分</h3><h4 id="A-MockStorage-存储层"><a href="#A-MockStorage-存储层" class="headerlink" title="A. MockStorage (存储层)"></a>A. <code>MockStorage</code> (存储层)</h4><p>负责数据的读写操作，核心特性是<strong>多域名隔离</strong>。</p>
<ul>
<li><strong>数据结构设计：</strong><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mockRules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev.example.com&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;/api/user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="attr">&quot;responseBody&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;test.example.com&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;/api/list&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="attr">&quot;responseBody&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;mockPanelPosition&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;top&quot;</span><span class="punctuation">:</span> <span class="string">&quot;100px&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;left&quot;</span><span class="punctuation">:</span> <span class="string">&quot;200px&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;mockPanelIsMinimized&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>API：</strong> <code>getRules()</code>, <code>setRule()</code>, <code>deleteRule()</code>, <code>saveRules()</code>。所有读写操作自动根据 <code>window.location.host</code> 进行 key 隔离。</li>
</ul>
<h4 id="B-NetworkMockPanel-视图层"><a href="#B-NetworkMockPanel-视图层" class="headerlink" title="B. NetworkMockPanel (视图层)"></a>B. <code>NetworkMockPanel</code> (视图层)</h4><p>基于 <code>HTMLElement</code> 的自定义组件。</p>
<ul>
<li><strong>Shadow DOM：</strong> 内部封装 <code>&lt;style&gt;</code> 和 HTML 模板，确保工具 UI 不受外部 CSS 影响（如全局 <code>box-sizing</code> 或 <code>reset.css</code>）。</li>
<li><strong>布局：</strong> 采用 Flex 布局。左侧为请求列表（支持筛选），右侧为详情&#x2F;编辑器（支持 Tab 切换）。</li>
<li><strong>交互特性：</strong><ul>
<li><strong>拖拽：</strong> 监听 <code>mousedown/mousemove/mouseup</code>，支持全屏拖拽。</li>
<li><strong>最小化&#x2F;恢复：</strong> 记录尺寸，切换显示模式，并更新按钮图标（<code>_</code> vs <code>□</code>）。</li>
<li><strong>Toast 通知：</strong> 替代 <code>alert</code>，在 Shadow DOM 内实现自毁式轻提醒。</li>
</ul>
</li>
</ul>
<h4 id="C-Interceptor-拦截层"><a href="#C-Interceptor-拦截层" class="headerlink" title="C. Interceptor (拦截层)"></a>C. <code>Interceptor</code> (拦截层)</h4><ul>
<li><strong>参数归一化：</strong> 处理 <code>fetch(url)</code> 和 <code>fetch(Request)</code> 两种调用方式，统一提取 URL 字符串。</li>
<li><strong>规则匹配：</strong> 支持精确匹配和通配符匹配（如 <code>/api/*</code>）。</li>
<li><strong>响应伪造：</strong> 使用 <code>new Response(body, init)</code> 构造符合 Fetch 标准的返回值。</li>
</ul>
<h3 id="3-2-关键代码实现摘要"><a href="#3-2-关键代码实现摘要" class="headerlink" title="3.2 关键代码实现摘要"></a>3.2 关键代码实现摘要</h3><p><strong>请求拦截核心逻辑：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originalFetch = <span class="variable language_">window</span>.<span class="property">fetch</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">fetch</span> = <span class="keyword">function</span> (<span class="params">input, init</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 参数处理</span></span><br><span class="line">    <span class="keyword">let</span> url = input <span class="keyword">instanceof</span> <span class="title class_">Request</span> ? input.<span class="property">url</span> : <span class="title class_">String</span>(input);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 规则匹配</span></span><br><span class="line">    <span class="keyword">const</span> rules = <span class="title class_">MockStorage</span>.<span class="title function_">getRules</span>(); <span class="comment">// 获取当前域名的规则</span></span><br><span class="line">    <span class="keyword">const</span> mockRule = <span class="title function_">findMatchingMockRule</span>(url, rules);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 命中 Mock</span></span><br><span class="line">    <span class="keyword">if</span> (mockRule &amp;&amp; mockRule.<span class="property">enabled</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回伪造的 Promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Response</span>(mockRule.<span class="property">responseBody</span>, &#123;</span><br><span class="line">            <span class="attr">status</span>: mockRule.<span class="property">statusCode</span>,</span><br><span class="line">            <span class="attr">headers</span>: &#123; <span class="string">&#x27;X-Mocked-By&#x27;</span>: <span class="string">&#x27;Tampermonkey&#x27;</span> &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 未命中，走真实请求并记录日志</span></span><br><span class="line">    <span class="keyword">return</span> originalFetch.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// Clone 响应以避免流被锁死</span></span><br><span class="line">        res.<span class="title function_">clone</span>().<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="function"><span class="params">body</span> =&gt;</span> <span class="title function_">logToPanel</span>(url, body));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-核心功能与优化"><a href="#4-核心功能与优化" class="headerlink" title="4. 核心功能与优化"></a>4. 核心功能与优化</h2><p>基于开发过程中的迭代，本工具包含以下高级特性：</p>
<h3 id="4-1-域名隔离支持"><a href="#4-1-域名隔离支持" class="headerlink" title="4.1 域名隔离支持"></a>4.1 域名隔离支持</h3><ul>
<li><strong>背景：</strong> 不同环境（Dev&#x2F;Test&#x2F;Prod）或不同项目的域名不同，共用一套规则会导致冲突。</li>
<li><strong>实现：</strong> <code>MockStorage</code> 在存取时自动追加 <code>window.location.host</code> 作为命名空间。</li>
</ul>
<h3 id="4-2-URL-智能筛选"><a href="#4-2-URL-智能筛选" class="headerlink" title="4.2 URL 智能筛选"></a>4.2 URL 智能筛选</h3><ul>
<li><strong>功能：</strong> 请求列表顶部提供输入框。</li>
<li><strong>实现：</strong> 监听 <code>input</code> 事件，实时遍历 DOM 列表，通过 <code>row.style.display</code> 控制显隐，解决接口过多难以查找的问题。</li>
</ul>
<h3 id="4-3-状态持久化"><a href="#4-3-状态持久化" class="headerlink" title="4.3 状态持久化"></a>4.3 状态持久化</h3><ul>
<li><strong>面板位置：</strong> 拖拽结束时记录 <code>top/left</code> 坐标，刷新后自动还原位置。</li>
<li><strong>最小化状态：</strong> 记录面板是否被收起。刷新页面后，若之前是最小化状态，工具会自动初始化并立即执行最小化逻辑。</li>
</ul>
<h3 id="4-4-交互体验优化"><a href="#4-4-交互体验优化" class="headerlink" title="4.4 交互体验优化"></a>4.4 交互体验优化</h3><ul>
<li><strong>Toast 轻提醒：</strong> 封装 <code>showToast</code> 方法，提供 Success&#x2F;Error 状态的非阻塞式通知。</li>
<li><strong>防误触拖拽：</strong> 在 Header 拖拽逻辑中，增加 <code>target</code> 检查。若点击的是 Header 内部的按钮（关闭&#x2F;最小化），则通过 <code>while</code> 循环向上查找并拦截，防止触发拖拽。</li>
<li><strong>长 URL 适配：</strong> 编辑器头部采用 <code>flex-wrap: wrap</code> 和 <code>word-break: break-all</code>，确保超长 URL 能够完整展示且不挤压操作按钮。</li>
</ul>
<h3 id="4-5-规则管理"><a href="#4-5-规则管理" class="headerlink" title="4.5 规则管理"></a>4.5 规则管理</h3><ul>
<li><strong>单条删除：</strong> 编辑器内提供删除按钮，删除特定 URL 规则。</li>
<li><strong>一键清空：</strong> 头部提供垃圾桶图标，清空当前域名下所有规则（带二次确认）。</li>
</ul>
<hr>
<h2 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h2><p>附上我的仓库地址:<br>油猴脚本版: <a target="_blank" rel="noopener" href="https://github.com/but0nly/scripts/blob/master/src/mock-network-panel.js">Mock-Network-Panel</a><br>npm包版: <a target="_blank" rel="noopener" href="https://github.com/but0nly/Mock-Network-Tool">Mock-Network-Tool</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://but0nly.github.io/2024/02/13/%E6%83%B3%E6%B3%95/%E5%AE%A2%E6%88%B7%E7%AB%AF%20Mock%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" data-id="cuiduwa1SO1PxZbaBEcmbSlLh" data-title="客户端 Mock 解决方案" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-前端工程化/工程化基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/11/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2023-12-10T16:00:00.000Z" itemprop="datePublished">2023-12-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/11/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%9F%BA%E7%A1%80/">前端工程化基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h3><h4 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h4><p>命令行工具，是用户与脚手架工具进行交互的入口。</p>
<ul>
<li><strong>定义</strong>：是一个命令行程序。（比如<code>vue create</code> 或 <code>npx create-react-app</code>）</li>
<li><strong>作用</strong>：负责接受用户输入的命令和参数，执行创建项目的逻辑。</li>
<li><strong>功能</strong>：根据你的选择，动态地从仓库拉取文件，并修改其中的配置。</li>
</ul>
<p><strong>CLI管理模板的机制</strong><br>管理多个不同的模板</p>
<ol>
<li>独立的Git仓库</li>
<li>独立的NPM包<blockquote>
<p>核心思想：解耦。把项目初始化结构的配置（Boilerplate）与创建项目的工具（CLI）分开</p>
</blockquote>
</li>
</ol>
<p><strong>命令行交互</strong><br><strong><code>Inquirer.js</code> 的作用：</strong> 它抽象了底层终端的输入输出，让我们能轻松地创建用户友好的提示（Prompts），从而根据用户的选择动态生成项目配置。</p>
<h4 id="Boilerplate"><a href="#Boilerplate" class="headerlink" title="Boilerplate"></a>Boilerplate</h4><p>脚手架工作的内容基础（预设的模板）</p>
<ul>
<li><strong>定义</strong>：一个预设好、可复用的项目模板</li>
<li><strong>作用</strong>：包含了一个开箱即用的项目所需的一切，例如<ul>
<li>文件结构：<code>src</code>、<code>plugins</code>等结构</li>
<li>基础代码：<code>App.vue</code>或<code>index.js</code>这样的文件</li>
<li>工程化配置：ESlint规则、webpack&#x2F;vite构建配置、TypeScript配置文件等</li>
</ul>
</li>
<li><strong>功能</strong>：项目规范化的体现，确保所有新项目都遵循团队设定的最佳实践。</li>
</ul>
<h4 id="工程价值"><a href="#工程价值" class="headerlink" title="工程价值"></a>工程价值</h4><p>实现<strong>一致性</strong>和<strong>可维护性</strong></p>
<ul>
<li>项目规范化<ul>
<li>一致的技术选型</li>
<li>统一的代码风格</li>
<li>标准化目录结构</li>
</ul>
</li>
<li>降低维护成本<ul>
<li>减少重复劳动</li>
<li>集中化配置更新</li>
</ul>
</li>
</ul>
<hr>
<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><table>
<thead>
<tr>
<th>特性</th>
<th>NPM</th>
<th>Yarn</th>
<th>PNPM</th>
</tr>
</thead>
<tbody><tr>
<td>诞生背景</td>
<td>Node.js默认自带</td>
<td>Facebook创建，为了解决<strong>性能</strong>和<strong>安全性</strong>问题</td>
<td>专注于<strong>效率</strong>和<strong>磁盘空间</strong>优化</td>
</tr>
<tr>
<td>依赖机构</td>
<td>扁平化，以解决Windows 路径过长的问题</td>
<td>扁平化，类似npm3+</td>
<td>内容可寻址存储。使用符号链接创建依赖</td>
</tr>
<tr>
<td>安装速度</td>
<td>较慢，新版本已经优化很多</td>
<td>较快，有并行安装和缓存机制</td>
<td>最快。所有模块只安装一次，通过链接引用</td>
</tr>
<tr>
<td>磁盘空间</td>
<td>占用空间大，每个项目都有完整的副本。</td>
<td>占用空间较大。</td>
<td>最节省，模块只在磁盘上存储一次，极大地节省了空间。</td>
</tr>
<tr>
<td>幽灵依赖</td>
<td>扁平化结构可能导致<strong>幽灵依赖</strong></td>
<td>扁平化结构可能导致<strong>幽灵依赖</strong></td>
<td>符号链接结构严格限制了项目中只能访问<code>package.json</code>中声明的依赖，有效解决了<strong>幽灵依赖</strong></td>
</tr>
</tbody></table>
<p><strong>深入pnpm的优势</strong><br><code>pnpm</code>通过独特的符号链接机制，解决了<code>npm</code>和<code>yarn</code>在磁盘空间和幽灵依赖的痛点。</p>
<ul>
<li>符号链接工作原理：当你执行<code>pnpm install</code>的时候，它在项目<code>node_modules</code>目录下创建的不是实际文件，而是指向一个<strong>全局唯一存储位置</strong>的符号链接。这样，10个项目如果都依赖同一个版本的 React，磁盘上只会存一份 React 的代码。</li>
</ul>
<hr>
<h3 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h3><table>
<thead>
<tr>
<th>知识点</th>
<th>核心作用</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>Dev-Server</td>
<td><strong>运行环境</strong>：一个简易的本地HTTP服务器，用于承载、编译并实时运行你提供的前端代码。</td>
<td>提供一个隔离、高效的沙盒环境，支持实时编译和HMR。</td>
</tr>
<tr>
<td>Hot-Reload</td>
<td><strong>状态保持</strong>：在不刷新整个页面的前提下，替换程序中被修改的模块</td>
<td>极大的加快开发速度，并保留应用程序的当前状态。</td>
</tr>
<tr>
<td>Mock</td>
<td><strong>前后端解耦</strong>：在后端API未完成时，模拟或拦截API请求并返回预设的假数据。</td>
<td>确保前端开发不受后端进度影响，可以独立、快速地进行。</td>
</tr>
<tr>
<td>Proxy</td>
<td><strong>跨域解决</strong>：将本地开发服务器（例如：<code>localhost：8000</code>）的API转发到真实的后端服务器（例如：<code>api.production.com</code>）</td>
<td>解决浏览器同源策略导致的<strong>CORS</strong>跨域问题</td>
</tr>
</tbody></table>
<hr>
<h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><table>
<thead>
<tr>
<th>工具</th>
<th>类型</th>
<th>核心机制</th>
<th>主要优势</th>
</tr>
</thead>
<tbody><tr>
<td>Webpack</td>
<td>打包器</td>
<td>依赖图谱：将一切视为模块，从入口开始构建复杂的依赖图，进行打包。</td>
<td><strong>成熟</strong>、<strong>功能强大</strong>：插件生态极度丰富，适用于各种复杂的生产环境需求。</td>
</tr>
<tr>
<td>Gulp</td>
<td>任务运行器</td>
<td>流式API：基于Node.js Streams，通过管道将文件依次传递给不同的任务插件进行处理。</td>
<td>自动化：非常适合执行重复性任务，如文件复制、图片压缩、Saas编译等。</td>
</tr>
<tr>
<td>Vite</td>
<td>构建构建</td>
<td>ES Modules + 预构建：开发环境基于浏览器的原生ESM，仅在需要时编译；生产环境使用Rollup打包。</td>
<td>极速：开发启动和热更新速度远超Webpack，极大提升了开发效率。</td>
</tr>
<tr>
<td>Snowpack</td>
<td>构建工具</td>
<td>原生ESM：率先利用原生 ESM 启动DEV Server，实现按需编译。</td>
<td>按需编译：彻底打破了传统打包模式，提高了开发速度（但目前Vite社区更有优势）</td>
</tr>
<tr>
<td><strong>深入分析：Webpack和Vite</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>方面</strong></th>
<th><strong>Webpack</strong></th>
<th><strong>Vite</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>开发环境启动速度</strong></td>
<td>慢。必须先完整扫描和打包所有模块。</td>
<td>极快。利用浏览器原生 ESM，无需打包，按需加载。</td>
</tr>
<tr>
<td><strong>热更新（HMR）</strong></td>
<td>较慢。当文件修改时，需要重新打包整个模块链。</td>
<td>极快。HMR 更新路径在原生 ESM 中，速度不受应用规模影响。</td>
</tr>
<tr>
<td><strong>生产环境打包</strong></td>
<td>强大且可定制，但配置复杂。</td>
<td>使用 <strong>Rollup</strong>，配置简单，打包结果高效。</td>
</tr>
</tbody></table>
<hr>
<h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI &#x2F; CD"></a>CI &#x2F; CD</h3><p><strong>什么是CI&#x2F;CD？</strong><br>CI&#x2F;CD是一套方法论和实践，旨在通过自动化，在软件开发生命周期中频繁、可靠的交互应用。</p>
<ol>
<li>持续集成（CI）<ol>
<li>目标：快速检测Bug。每当代码合到主干（如<code>main</code>）分支时，自动触发构建（build）、运行单元测试和代码质量检查（linting）</li>
</ol>
</li>
<li>持续交付&#x2F;部署（CD）<ol>
<li>目标：可靠交付。<ol>
<li>交付：代码通过所有测试后，自动准备好部署，等待人工审批发布。</li>
<li>部署：代码通过所有测试后，自动发布到生产环境，无需人工干预。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>大体流程</strong></p>
<ul>
<li>CI流程<ol>
<li>安装依赖（<code>npm install</code>）<ol>
<li><code>Lock</code>文件重要性。版本锁死</li>
</ol>
</li>
<li>运行测试与质量检查<ol>
<li>单元测试：验证最小代码单元是否按预期工作</li>
<li>集成测试：验证多个模块合在一起是否能够正确协作</li>
<li>代码校验：运行<code>ESLint</code>和<code>TypeScript</code>检查</li>
</ol>
</li>
<li>构建最终产物（<code>npm build</code>）<ol>
<li>编译转换</li>
<li>代码优化</li>
<li>资源处理</li>
</ol>
</li>
</ol>
</li>
<li>CD流程<ol start="4">
<li>存储构建产物<ol>
<li>原理：在CI&#x2F;CD流程中，我们不会直接执行<code>npm run build</code>的那台CI机器上部署文件。原因很简单因为CI机器通常是<strong>临时</strong>的，一旦完成任务就会销毁。</li>
<li>上传与储存：将生产的<code>dist</code>文件目录中的所有文件打包成一个<code>.zip</code>文件，然后上传到一个构建产物仓库</li>
<li>目的：解耦<strong>Build</strong>和<strong>Deploy</strong>,避免构建机器挂了，构建产物也是安全的。</li>
<li>可追溯与回滚：每个构建产物都有唯一的 ID 和版本号。如果部署到生产环境后发现问题，我们可以随时从仓库中取出<strong>前一个版本</strong>的产物进行<strong>快速回滚</strong>，保证服务的稳定性。</li>
</ol>
</li>
<li>部署到生产环境<ol>
<li>下载产物：CD流程或部署代理从 Artifact 仓库(如S3)下载最新版本的构建产物。</li>
<li>环境准备：将产物解压，放置在Web服务器的特定目录下。</li>
<li>服务切换：需要用技术手段将用户流量从旧版本平滑切换到新版本。<ol>
<li>滚动部署：一台一台地替换，直到所有服务器都更新完毕。（风险低，如果有问题可以随时停止替换。）</li>
<li>蓝绿部署：维护两套完全相同的生产环境，测试完毕后，一件将用户流量从蓝色环境切换到绿色环境。（极速切换和回滚，用户几乎察觉不到部署过程）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h3><blockquote>
<p>核心思想：去耦合，它将应用拆分，从而实现了 <strong>技术选择的自由</strong> 和 <strong>渐进式升级</strong>。</p>
</blockquote>
<p>将一个庞大的、单一技术栈的巨石应用拆分成多个独立开发、独立部署、独立运行的小型应用，最后这些小型应用在浏览器中无缝集成。</p>
<p><strong>解决两大痛点：</strong></p>
<ol>
<li>组织与协作的痛点<ul>
<li>代码冲突与评审瓶颈:  所有人都在同一个巨大的代码仓库中工作。合并请求（PR）会非常多，很容易发生代码冲突（Merge Conflicts）。此外，任何修改都需要通过少数核心维护者的评审，导致<strong>发布周期变长</strong>，成为协作的瓶颈。</li>
<li>责任边界模糊: 团队难以按业务线（如：支付团队、商品团队、用户中心团队）进行完全独立的开发和部署。大家都在同一个代码库里，导致<strong>权责不清</strong>，协作成本极高。</li>
</ul>
</li>
<li>技术与拓展的痛点<ul>
<li>技术栈锁死: 一旦选择了 React 或 Vue 的某个版本，整个应用就被“锁死”在这个技术栈上。想要升级版本或引入一个新的框架（如 Svelte）会变得极其困难和昂贵。这阻碍了团队采用新技术来提高效率。</li>
<li>构建与部署缓慢: 即使只修改了一个小按钮的样式，也需要<strong>重新构建和部署</strong>整个庞大的应用。这使得 CI&#x2F;CD 流程变慢，严重拖慢了反馈周期和发布频率。</li>
</ul>
</li>
</ol>
<p><strong>物理拆分后</strong></p>
<ol>
<li>明确的责任边界<ul>
<li>物理隔离即责任隔离</li>
<li>全栈所有权</li>
<li>结果</li>
</ul>
</li>
<li>消除协作瓶颈<ul>
<li>独立的部署周期</li>
<li>减少代码冲突</li>
</ul>
</li>
</ol>
<p><strong>集成层如何实现隔离？</strong><br>微前端的集成层（通常由 <code>single-spa</code>、<code>Qiankun</code> 或 <code>MicroApp</code> 等框架实现）主要从两个方面入手：</p>
<ol>
<li><p>CSS&#x2F;样式隔离（相对简单）</p>
<ul>
<li><strong>命名规范：</strong> 使用 BEM 或 CSS Modules，确保组件级别的类名是唯一的。</li>
<li><strong>Shadow DOM：</strong> 使用 Web Components 的 Shadow DOM 特性，为每个微应用创建一个隔离的 DOM 子树，样式完全无法泄漏到外部或从外部泄漏进来。</li>
</ul>
</li>
<li><p>JavaScript 沙箱（JS Isolation - 技术难度高）<br>这是防止全局污染的核心。最流行的做法是实现一个 <strong>JS 沙箱（Sandbox）</strong>，让每个微应用认为自己是运行在一个<strong>干净的、独立的 <code>window</code> 环境</strong>中。</p>
</li>
</ol>
<ul>
<li>如何实现：使用 Proxy 创建代理，拦截写入，局部存储（将这个修改存储到沙箱内部的字典当中）</li>
</ul>
<p><strong>核心价值观</strong><br>业务敏捷性</p>
<ul>
<li>解耦组织</li>
<li>解耦技术栈</li>
<li>解耦应用<br>敏捷性意味着前端团队可以根据市场需求，<strong>更快、更频繁、更可靠</strong>地交付新功能，而不是被单一的代码库或漫长的发布周期所拖累。</li>
</ul>
<p><strong>变更检测</strong><br>它让CI&#x2F;CD知道哪些部分需要工作，哪些部分可以跳过。</p>
<p>大的代码仓库（Monorepo）</p>
<ol>
<li>物理隔离：每个微应用（如 <code>/cart</code>、<code>/user</code>）都有自己独立的文件夹，包含自己的 <code>package.json</code>、<code>vite.config.js</code> 和 CI 配置文件。</li>
<li>变更检查：CI&#x2F;CD 系统（如 GitHub Actions 或 Jenkins）在收到新的代码提交时，会先检查这次提交<strong>修改了哪些文件</strong>。</li>
<li>精确执行：如果发现只有 <code>/cart</code> 文件夹下的文件发生了变化，CI&#x2F;CD 就会执行一个<strong>条件判断</strong>：<ul>
<li><strong>只运行</strong> <code>/cart</code> 微应用的 <code>npm install</code>、<code>npm run test</code> 和 <code>npm run build</code>。</li>
<li><strong>完全跳过</strong> <code>/user</code>、<code>/product</code> 等未修改的微应用的相关流程。</li>
</ul>
</li>
</ol>
<p>变更检测逻辑</p>
<ol>
<li>识别变更文件<ol>
<li>CI会使用git命令来比较当前分钟和目标分支之间的差异，从而获取所被修改的文件列表</li>
</ol>
</li>
<li>使用条件判断<ol>
<li>一旦有了文件列表，就可以在CI配置文件中添加条件判断，让工作流只在特定路径下的文件被修改时执行。</li>
</ol>
</li>
</ol>
<hr>
<h3 id="BFF"><a href="#BFF" class="headerlink" title="BFF"></a>BFF</h3><p>前端应用在尝试直接与多个后端微服务通信时，最容易出现两个核心问题。</p>
<ol>
<li>性能与”聊天“问题<ol>
<li>痛点：如果一个页面需要聚合展示三个模块的信息，需要发出3个独立的HTTP请求。如果页面复杂，请求数量会更多。</li>
<li>后果：增加请求的<strong>往返延迟</strong></li>
</ol>
</li>
<li>数据聚合与处理的复杂性<ol>
<li>痛点：如果每个微服务返回的数据结构都是通用的，不一定完全匹配前端的页面需求。</li>
<li>后果：前端必须自己负责数据的<strong>聚合</strong>、<strong>转换</strong>和<strong>裁剪</strong></li>
</ol>
</li>
</ol>
<p><strong>解决方案：BFF（Back end for Front end）</strong><br>专为前端应用定制的中间服务层。</p>
<p>解决了：</p>
<ol>
<li>减少请求次数：BFF数据聚合。</li>
<li>数据整形：负责将转换、裁剪后的数据返回给前端。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://but0nly.github.io/2023/12/11/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%9F%BA%E7%A1%80/" data-id="cuidA8IoiCxtYMOkQUSsCPdHC" data-title="前端工程化基础" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-重学前端/前端优化有哪些" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/17/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B/" class="article-date">
  <time class="dt-published" datetime="2023-10-16T16:00:00.000Z" itemprop="datePublished">2023-10-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/17/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B/">前端优化有哪些</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><hr>
<ul>
<li>DNS 预解析： 提前解析IP地址 通过link标签 rel 设置 “dns-prefetch”</li>
<li>图片不要设置空的src：因为这样也会发出http请求</li>
<li>请求多域名：一些浏览器会限制同域名的并发数量，可以控制到2-4个域名。</li>
<li>使用缓存：协商缓存和强缓存，直接从本地取数据</li>
<li>CDN网络：区域分发</li>
<li>压缩响应：Accept-Encoding 头来标识压缩支持，</li>
</ul>
<h3 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h3><hr>
<ul>
<li>降低选择器的复杂度：<ul>
<li>减少嵌套</li>
<li>避免使用通配符</li>
<li>利用继承</li>
<li>正确使用类选择器和ID选择器</li>
</ul>
</li>
<li>避免渲染阻塞：CSS使用Link标签或者CDN加速，尽早的加载CSS文件，避免影响合成renderTree</li>
<li>避免使用CSS表达式：会频繁计算</li>
<li>避免JS阻塞：使用defer和async，延迟脚本执行；</li>
<li>使用外链的JS和CSS：浏览器可以缓存他们，减少http请求</li>
<li>使用图标iconfont替代图片</li>
<li>首屏加载优化：<ul>
<li>使用骨架图或者加载动画</li>
<li>按需加载，首页用不到的资源延迟加载</li>
</ul>
</li>
<li>减少重绘和回流<ul>
<li>使用createDocumentFragment：不是真实的DOM部分</li>
<li>translate：不会触发回流</li>
<li>通过<code>display：none</code>把DOM离线了再修改，修改完了再把它显示出来</li>
<li>批量处理DOM操作</li>
<li>使用 <code>requestAnimationFrame</code> 处理动画</li>
</ul>
</li>
</ul>
<h3 id="JS优化"><a href="#JS优化" class="headerlink" title="JS优化"></a>JS优化</h3><hr>
<ul>
<li>避免使用JS动画</li>
<li>使用事件委托</li>
<li>防抖和节流</li>
<li>多进程 webworker</li>
<li>计算结果缓存</li>
</ul>
<h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><hr>
<ul>
<li>雪碧图</li>
<li>图片懒加载</li>
<li>使用CSS3代表图片</li>
<li>图片压缩</li>
<li>使用渐进式jpeg</li>
<li>使用webp格式的图片：体积小</li>
</ul>
<h2 id="webpack-打包优化"><a href="#webpack-打包优化" class="headerlink" title="webpack 打包优化"></a>webpack 打包优化</h2><hr>
<ul>
<li>缩小loader匹配范围</li>
<li>resolve.modules</li>
<li>抽离CSS<ul>
<li>mini-css-extract-plugin，将CSS提取到单独的文件中，为每个包含CSS的JS文件创建一个CSS文件，并支持CSS 和 SourceMaps的按需加载。</li>
</ul>
</li>
</ul>
<h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><ul>
<li>JS代码压缩<ul>
<li>terser-webpack-plugin</li>
</ul>
</li>
<li>CSS代码压缩<ul>
<li>css-minimizer-webpack-plugin</li>
</ul>
</li>
<li>HTML压缩<ul>
<li>html-webpack-plugin</li>
</ul>
</li>
</ul>
<h3 id="文件大小压缩"><a href="#文件大小压缩" class="headerlink" title="文件大小压缩"></a>文件大小压缩</h3><p>对文件的大小进行压缩，减少<code>http</code>传输过程中宽带的损耗</p>
<p>使用compression-webpack-plugin</p>
<h3 id="Tree-shaking"><a href="#Tree-shaking" class="headerlink" title="Tree shaking"></a>Tree shaking</h3><p>摇树，利用 ESM 去除死代码</p>
<h3 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h3><p>将代码分离到不同的<code>bundle</code>中，之后我们可以按需加载，或者并行加载这些文件</p>
<p>代码分离可以分出更小的<code>bundle</code>，以及控制资源加载有现价，提供代码的加载性能</p>
<p>我们通过 <code>splitChunksPlugin</code> 来实现</p>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><hr>
<ul>
<li>渲染列表加key</li>
<li>合理使用computed和watch</li>
<li>路由懒加载</li>
<li>第三方插件按需引入</li>
<li>destory：销毁事件解绑自定义事件、setTimeout、DOM事件</li>
</ul>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><hr>
<ul>
<li>渲染列表加key</li>
<li>使用SCU避免重新渲染</li>
<li>路由懒加载</li>
<li>第三方插件按需引入</li>
<li>合理使用useMemo、memo、useCallback 缓存变量或者方法</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://but0nly.github.io/2023/10/17/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B/" data-id="cuid_PR1336jiEQ0eXHLQ4AfP" data-title="前端优化有哪些" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-前端工程化/webpack的原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/08/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack%E7%9A%84%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2023-10-07T16:00:00.000Z" itemprop="datePublished">2023-10-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/08/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack%E7%9A%84%E5%8E%9F%E7%90%86/">Webpack的原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>webpack</strong>是一个打包器，主要目标将多种模块打包成浏览库可以加载执行的文件。</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ol>
<li><em>entry</em>（入口）</li>
<li><em>Dependency Graph</em>（依赖图）</li>
<li><em>output</em>（输出）</li>
<li><em>loaders</em>（加载器）</li>
<li><em>plugins</em>（插件）</li>
</ol>
<h3 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h3><ol>
<li><strong>初始化</strong>（读取配置，创建<em>Compiler</em>）<ol>
<li>读取配置：加载（<code>webpack.config.json</code>）文件中的配置（Entry\output\loaders\plugins等）</li>
<li>创建<em>Compiler</em>实例：是Webpack的一个核心对象，包含了整个打包环境和配置信息。</li>
</ol>
</li>
<li><strong>编译&amp;模块构建</strong>（<em>Compiler</em>启动<em>Compilation</em>，从<strong>Entry</strong>开始编译）<ol>
<li>生成<code>Compilation</code>编译对象：由 Compiler 创建，它负责<strong>执行</strong>一次完整的打包会话。它包含了当前打包过程中的所有信息，如模块、依赖关系、资源块（Chunks）等等</li>
<li>Compilation 实例从配置的<em>Entry</em>入口开始。</li>
<li>将<em>Entry</em>文件视为一个模块，然后利用<strong>Loaders</strong>来处理这个文件内容。</li>
<li>在处理过程中，webpack会解析文件中所有的<code>import</code>、<code>require</code></li>
</ol>
</li>
<li><strong>模块解析</strong>（确定所有依赖的绝对路径）<ol>
<li>在模块中遇到<code>import &quot;react&quot;</code>或者<code>import &quot;./utils.js&quot;</code>，就会通过<em>解析机制</em>来确定文件的物理文件路径在哪。</li>
<li>配合<strong>加载器</strong>转换，并放到<strong>依赖图</strong>中</li>
</ol>
</li>
<li><strong>分块</strong><ol>
<li>将这些模块（Chunk）组织成文件</li>
</ol>
</li>
<li><strong>优化&amp;代码分割</strong><ol>
<li>优化：<code>tree-shaking</code>、<code>minification</code></li>
<li>代码分割：<ol>
<li>按需加载：<code>import()</code></li>
<li>缓存优化：将第三方库分割成<code>vendor chunk</code>，方便浏览器存储。</li>
</ol>
</li>
</ol>
</li>
<li><strong>资源生成&amp;写入</strong><ol>
<li>资源生成：Compilation 将内存中优化好的 chunks 映射成一个或多个<em>Assets</em></li>
<li>写入：根据<code>webpack</code>中配置的output规则，将这些文件写入到系统中。</li>
</ol>
</li>
</ol>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ol>
<li>读取配置，创建<em>Compiler</em>。</li>
<li><em>Comiler</em>启动<em>Compilation</em>，从<strong>Entry</strong>开始。</li>
<li>模块解析：确定所有依赖的绝对路径。</li>
<li>加载器转换：使用<strong>Loaders</strong>处理非JS文件。</li>
<li>分块和优化：将模块组织成&#x3D;&#x3D;Chunks&#x3D;&#x3D;，并进行 <em>Tree Shaking</em> 优化。</li>
<li>资源写入：根据<strong>Output</strong>配置生成并写入到系统中。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://but0nly.github.io/2023/10/08/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack%E7%9A%84%E5%8E%9F%E7%90%86/" data-id="cuidOoIYLBOuuFsLk4KLlkqBS" data-title="Webpack的原理" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-前端工程化/webpack的执行流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/08/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2023-10-07T16:00:00.000Z" itemprop="datePublished">2023-10-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/08/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/">Webpack的执行流程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>webpack</strong>启动后会在entry配置的module开始递归解析 每找到一个module，就会根据配置loader的去找对应的转换规则，对module进行转换后开始解析module所依赖的module，然后这些模块以entry分组，一个entry和所有相依赖的模块对应一个chunk，最后webpack会把有所有的chunk转换成文件输出，在整个流程中，webpack会在恰当的时机执行plugin的逻辑。</p>
<ol>
<li>会从 <em>entry</em> 第一个 <code>module</code> 开始递归解析</li>
<li>每找到一个 <code>module</code> 就会根据配置的<em>loader</em>规则转换</li>
<li>转换后开始解析 <code>module</code> 所依赖的 <code>module</code> </li>
<li>然后这些 <code>module</code> 以 <em>entry</em> 分组，一个 <em>entry</em> 所依赖的模块对应一个 &#x3D;&#x3D;chunk&#x3D;&#x3D;</li>
<li><strong>webpack</strong> 会把这些 &#x3D;&#x3D;chunk&#x3D;&#x3D; 转换成文件根据 <em>output</em> 输出</li>
<li>整个流程中 <em>plugins</em> 会在适当的时机执行</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://but0nly.github.io/2023/10/08/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" data-id="cuid0yzb4uBYxE_yBI3bR7sn4" data-title="Webpack的执行流程" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-浏览器原理/浏览器的性能指标" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" class="article-date">
  <time class="dt-published" datetime="2023-10-06T16:00:00.000Z" itemprop="datePublished">2023-10-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/">浏览器的性能指标</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>浏览器性能指标主要关注<strong>用户感知</strong>，即用户觉得页面加载速度如何。</p>
<p>三个重要指标：</p>
<ul>
<li><em><strong>LCP</strong></em>（最大的内容绘制）：衡量页面主要内容的加载所需时间。</li>
<li><em><strong>INP</strong></em>（交互到下一次绘制）：衡量网页的响应性。</li>
<li><em><strong>CLS</strong></em> (累积布局偏移)：衡量页面加载中，非预期的视觉内容移动的累积总分</li>
</ul>
<h3 id="LCP"><a href="#LCP" class="headerlink" title="LCP"></a><em><strong>LCP</strong></em></h3><p><em><strong>LCP</strong></em>是衡量浏览器渲染<em>视口内可见的最大图像或者元素</em>所需时间。</p>
<p>一个优秀的LCP目标是页面加载时间在<strong>2.5以内</strong>。</p>
<p>关键渲染路径：</p>
<ul>
<li><strong>优化服务器响应时间</strong></li>
<li><strong>资源加载优先级</strong></li>
<li><strong>阻塞渲染的资源</strong></li>
</ul>
<h4 id="优化服务器响应时间"><a href="#优化服务器响应时间" class="headerlink" title="优化服务器响应时间"></a>优化服务器响应时间</h4><p>一个关键因素<strong>TTFB</strong>（首次字节时间），如果跑慢了，后面的<em><strong>LCP</strong></em>无论如何都会收到影响</p>
<p>最佳<strong>TTFB</strong>时间是<strong>0.8秒以内</strong></p>
<blockquote>
<p><strong>TTFB</strong>：是衡量用户点击链接到服务器返回的第一个字节所需的时间<br>包括三个阶段：</p>
<ul>
<li>网络延迟：客户端发生请求到服务器所需时间</li>
<li>服务器处理时间：服务器运行代码、查询数据库、生成<em>HTML</em>的时间</li>
<li>响应时间：服务器将响应的第一个字节发送回客户端的时间</li>
</ul>
</blockquote>
<p>优化方案：</p>
<ul>
<li>后端代码与数据库</li>
<li><strong>内容分发网络（CDN）于边缘计算</strong><ul>
<li>CDN的工作原理：<ol>
<li><em>DNS的引导</em>：CDN的服务商通过特殊的DNS解析技术，引导用户的请求到<strong>地理位置离他们最近的CDN节点</strong>（或者Pop）</li>
<li><em>缓存检查</em>：最近的这个CDN节点会检查它的本地存储中是否有所请求的资源</li>
<li><em>内容交付</em>：<ol>
<li><em>缓存命中</em>：如果存在这个资源，节点就会立即发送给用户。这是最快的路径，能大幅度减少<em><strong>LCP</strong></em>。</li>
<li><em>缓存未命中</em>：如果资源不在本地，就会去请求原始服务器，把响应回来的资源复制出副本存在本地，同时把资源发送给用户。</li>
</ol>
</li>
</ol>
</li>
<li>&#x3D;&#x3D;边缘计算：CDN的进阶版本&#x3D;&#x3D;</li>
</ul>
</li>
<li>缓存策略：[[HTTP 缓存]]</li>
</ul>
<h4 id="资源加载优先级"><a href="#资源加载优先级" class="headerlink" title="资源加载优先级"></a>资源加载优先级</h4><p>即使<strong>服务器响应时间</strong>很快，浏览器在解析<em>HTML</em>时，如果不加予干预，它可能会平等的对待所有资源，或者因为遇到堵塞的<em>CSS</em>或<em>JS</em>而延后发现<em><strong>LCP</strong></em>元素所需的资源。</p>
<p>我们的目标是需要使用<strong>预加载指令</strong>来告诉浏览器，这个资源需要立即下载。</p>
<p><code>Preload</code><br>可以在<em>link</em>标签加上属性<code>rel=preload</code>，当预加载扫描器发现<code>Preload</code>后，它会立即启动对该资源的下载，并赋予<strong>极高优先级</strong><br>有时候，存在多个<strong>预加载资源</strong>时，浏览器还是没办法确定哪个优先级更高，所以我们还有个更高级的用法，是在<code>rel=preload</code>的基础上再结合<code>fetchpriority=&quot;high&quot;</code>,</p>
<blockquote>
<p>我们可以给<em><strong>LCP</strong></em>元素做预加载，进而<em><strong>LCP</strong></em>所需时间。</p>
</blockquote>
<h4 id="阻塞渲染的资源"><a href="#阻塞渲染的资源" class="headerlink" title="阻塞渲染的资源"></a>阻塞渲染的资源</h4><p>即使服务器响应速度、LCP资源也提前加载，但是浏览器在<strong>解析</strong>和<strong>渲染</strong>过程中遇到堵塞的CSS和JS，整个页面的首次绘制仍然会被暂停。</p>
<p>⚠️阻塞机制</p>
<ul>
<li><em>CSS</em>：CSS会暂停渲染，因为浏览器需要完整的CSSOM才开始渲染。这是因为CSS规则可以影响页面上的任何元素，所以，当浏览器遇到外部的<code>&lt;link rel=&quot;stylesheet &gt;&quot;</code>标签时，它会暂停渲染，直到CSS文件下载并解析完毕。</li>
<li><em>JavaScript</em>：浏览器遇到<code>&lt;script&gt;</code>标签时,JS会暂停HTML解析，直到JS文件下载、解析和执行完毕，这是因为<strong>JS有可能会改变DOM结构</strong></li>
</ul>
<h5 id="关键CSS"><a href="#关键CSS" class="headerlink" title="关键CSS"></a><strong>关键CSS</strong></h5><p>核心思路，只取出最关键、刚好满足首页渲染的CSS，而延迟其他非关键CSS的加载</p>
<p>优化技术：</p>
<ul>
<li><em>提取关键CSS</em>：使用第三方工具分析并将这些关键规则提取出来，插入到<code>head</code>中的<code>style</code>标签。<ul>
<li>&#x3D;&#x3D;需要注意，虽然这样会增加html的体积，但是正向收益还是可观的&#x3D;&#x3D;</li>
</ul>
</li>
<li><em>延迟非关键的CSS</em>：<ul>
<li>使用<code>media=&quot;print&quot;</code>欺骗浏览器，让浏览器认为这个样式表只用于打印，所以下载时不阻塞渲染。</li>
<li>使用<code>rel=&quot;preload&quot;</code>预加载法，不阻塞渲染，能以高优先级尽快下载资源。</li>
</ul>
</li>
</ul>
<p><strong>延迟JavaScript加载</strong><br>对不阻塞首次渲染的脚步，使用<code>async</code>和<code>defer</code>（依赖DOM，在<code>ContentDownload</code>之前加载），使其在后台下载，不阻塞<em>HTML</em>解析。</p>
<h3 id="INP"><a href="#INP" class="headerlink" title="INP"></a><em><strong>INP</strong></em></h3><p>衡量用户从交互到浏览器<strong>绘制出视觉反馈</strong>所需时间</p>
<p>一个优秀的INP时间为<strong>200毫秒</strong>以内，超过这个值，用户就会感觉到卡顿。</p>
<p>首先我们要知道INP的时间分为三个阶段：</p>
<ol>
<li><strong>输入延迟</strong><ol>
<li>用户交互（点击按钮）到出发事件函数的时间</li>
<li>延迟原因：会受到大型JavaScript文件加载或者执行一个耗时的函数。</li>
</ol>
</li>
<li><strong>处理时间</strong>（<em>主要</em>）<ol>
<li>事件函数触发，执行的JavaScript代码的所需时间</li>
<li>延迟原因：JavaScript代码本身运行耗时过大，或者进行大量的DOM操作</li>
</ol>
</li>
<li><strong>呈现延迟</strong><ol>
<li>事件处理程序运行完成后，到浏览器实际绘制所需时间。</li>
<li>延迟原因：浏览器需要重新计算新的样式、进行布局和绘制。可能因为之前主线程的繁忙而被推迟</li>
</ol>
</li>
</ol>
<p>我们主要从影响最大的<strong>处理时间</strong>来优化，处理时间为什么最具影响力呢，因为在JavaScript中如果一个代码执行超过50ms，它就会被认为是<strong>长任务</strong>。</p>
<blockquote>
<p>🚨瓶颈：长任务。<br>长任务运行期间，主线程完全被占用，无法执行以下操作。</p>
<ol>
<li>响应其他用户输入</li>
<li>处理网络事件</li>
<li>页面渲染</li>
</ol>
</blockquote>
<p>解决这个问题的核心策略是：<strong>将长任务分解成小块，并允许主线程在小块之间“喘息”（Yielding）</strong>。</p>
<h4 id="任务分解与-yielding（喘息）"><a href="#任务分解与-yielding（喘息）" class="headerlink" title="任务分解与 yielding（喘息）"></a>任务分解与 yielding（喘息）</h4><p>使用<code>setTime(0)</code>来把长任务拆成多个短任务，运用宏任务机制来给主线程喘息的机会。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">chunkedTask</span>(<span class="params">items</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> chunkSize = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">processChunk</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 100 个项目</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; chunkSize &amp;&amp; i &lt; items.<span class="property">length</span>; j++, i++) &#123;</span><br><span class="line">      <span class="comment">// 耗时操作...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; items.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// 关键步骤：使用 setTimeout(0) 将剩余任务推迟到下一个事件循环周期</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(processChunk, <span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">processChunk</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#x3D;&#x3D;yielding（喘息）：空出来的喘息时间，可以用于上面的<em>输入延迟</em>和<em>呈现延迟</em>两个阶段。&#x3D;&#x3D;</p>
<h4 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h4><p><em>Web Worker</em>主要的工作原理就是将JavaScript代码放到<strong>后台线程</strong>中去执行，从而不影响主线程的运行。</p>
<p>优点：</p>
<ul>
<li>非阻塞</li>
<li>响应性</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法操作<em>DOM</em></li>
</ul>
<p>但是因为是后台线程，是一个独立的环境，所以没有办法操作<em>DOM</em>，所以只适合处理复杂的数学计算和加密解密等操作。</p>
<p>因为没有办法去操作<em>DOM</em>，所以Web Worker是通过<strong>消息传递</strong>去通知主线程：我这边数据算好了，你那边可以执行渲染操作了，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程代码示例</span></span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 当 Worker 线程发送数据回来时，这个回调函数就会被触发</span></span><br><span class="line">  <span class="keyword">const</span> result = event.<span class="property">data</span>;</span><br><span class="line">  <span class="title function_">updateUI</span>(result); <span class="comment">// 在这里安全地更新 DOM</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Web Worker</strong>的消息传递，也是回调的一种，所以会加入到<em>Call Back Queue</em>中等待执行</p>
</blockquote>
<h3 id="昂贵的DOM操作"><a href="#昂贵的DOM操作" class="headerlink" title="昂贵的DOM操作"></a>昂贵的DOM操作</h3><p>真正大的开销就是<strong>重排（Layout）</strong>；</p>
<p>🚨陷阱：<em>强制同步布局</em><br>通常发生在<em>写入</em>完成后，再<em>读去</em>元素的属性。</p>
<p>解决方案：主要一个优化手段就是集中处理DOM，<strong>读取</strong>和<strong>写入</strong>操作完全分开。利用<code>setTime(0)</code>去分隔读和写，写入时不会受<em>强制同步布局影响</em></p>
<h2 id="CLS"><a href="#CLS" class="headerlink" title="CLS"></a><em><strong>CLS</strong></em></h2><p><strong>累积布局偏移</strong><br>衡量的是页面加载过程中，<strong>非预期</strong>的视觉内容移动的累积总分。</p>
<p>优秀的CLS总分应该<strong>低于0.1</strong></p>
<p>分数计算公式：<br>$$CLS &#x3D; \text{Impact Fraction} \times \text{Distance Fraction}$$</p>
<ul>
<li>Impact Fraction（影响分数）：布局移动后，受影响元素在视图中所占区域的比例。</li>
<li>Distance Fraction（距离分数）：受影响元素在视口中移动的距离占视口尺寸的比例。</li>
</ul>
<p>影响CLS分数的罪魁祸首有哪些：</p>
<ul>
<li>没有设置尺寸的图片</li>
<li>延时加载的字体</li>
<li>动态注入的广告</li>
</ul>
<h4 id="解决没有尺寸的媒体"><a href="#解决没有尺寸的媒体" class="headerlink" title="解决没有尺寸的媒体"></a>解决没有尺寸的媒体</h4><p><code>aspect-ratio：【width】/【height】</code>设置宽高比。让容器始终保持一个特定的宽高比。</p>
<p><strong>关键点:</strong> 无论这个容器的宽度是多少，它的高度都会根据这个 <code>aspect-ratio</code> 自动计算并被 <strong>锁定</strong>。这样，即使图片文件本身还没加载完成，浏览器也已经为它预留了一个完美的矩形空间。</p>
<p>因为空间是预留的，所以当图片加载完成时，它只会填充这个预留空间，而<strong>不会</strong>向下推挤任何内容，从而<strong>消除</strong>了由图片加载导致的 CLS。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://but0nly.github.io/2023/10/07/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" data-id="cuidF8QMBFUnHZWPhmwLsJiwb" data-title="浏览器的性能指标" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-浏览器原理/缓存" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E7%BC%93%E5%AD%98/" class="article-date">
  <time class="dt-published" datetime="2023-10-05T16:00:00.000Z" itemprop="datePublished">2023-10-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E7%BC%93%E5%AD%98/">HTTP 缓存</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>两小节</p>
<ul>
<li><em>http</em>的缓存机制（强缓存 + 协商缓存）</li>
<li>刷新操作方式，对缓存的影响</li>
</ul>
<hr>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ol>
<li>把一些没有必要再获取的东西，存储起来</li>
<li>为什么需要缓存？<ul>
<li>cpu的计算都很快（毫秒级别），但是网络请求是最慢的，再怎么也需要个（几百毫秒）</li>
<li>有些很关键的性能优化得从网络去入手（为了访问得更快）<ul>
<li>减少体积</li>
<li>减少请求次数</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><ol>
<li>客户端发出初次请求</li>
<li>服务端认为这个资源可以被缓存</li>
<li>返回资源并加上<code>Cache-Contorl</code></li>
<li>这个资源就会被存在本地</li>
<li>当我们发出去第二次请求，如果<code>Cache-Contorl</code>设置的时间没有结束</li>
<li>浏览器会帮我们从本地去取这个资源，不会发送至服务端</li>
<li>但缓存失效时，我们会再次请求服务端</li>
</ol>
<h4 id="Cache-Contorl"><a href="#Cache-Contorl" class="headerlink" title="Cache-Contorl"></a>Cache-Contorl</h4><ul>
<li><code>max-age</code> （单位s）</li>
<li><code>no-cache</code> （别被名字给带偏了，这个是强制协商，而不是不缓存）</li>
<li><code>no-store</code> （不缓存）</li>
<li><code>private</code></li>
<li><code>public</code>：公开共享，<em>中间代理服务器</em>和<em>CDN</em>也可以缓存这个文件。</li>
<li><code>immunitable</code>：不可变，告诉浏览器<strong>不要执行任何启发式检查</strong>，完全相信<code>max-age</code></li>
</ul>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><ul>
<li>也是控制缓存过期</li>
<li>被<code>Cache-Contorl</code>替代</li>
</ul>
<h4 id="业务体现"><a href="#业务体现" class="headerlink" title="业务体现"></a>业务体现</h4><p>适用于不经常变动的静态资源，例如：列表的筛选的下拉，通过减少请求次数来提高加载速度和减少服务器压力。</p>
<hr>
<h2 id="协商缓存（对比缓存）"><a href="#协商缓存（对比缓存）" class="headerlink" title="协商缓存（对比缓存）"></a>协商缓存（对比缓存）</h2><p>服务端缓存策略<br>服务端判断客户端资源，是否和服务端的一样</p>
<ul>
<li>客户端发起初次请求</li>
<li>服务端认为需要缓存这个资源</li>
<li>返回资源和资源标识</li>
<li>再次请求到服务端的时候，服务端会对比这个标识，是否有更新，</li>
<li>如果没有，则返回304，从本地拿资源（体积小）</li>
<li>如果有，则返回新的资源和新的资源标识</li>
</ul>
<p><em>协商缓存</em>的主要字段</p>
<ul>
<li><code>Etag</code>（资源的唯一标识）服务端返回</li>
<li><code>If-None-Match</code> （资源的唯一标识）客户端发送的时候带上</li>
<li><code>Last-Modified</code> （资源最后修改时间）服务端返回</li>
<li><code>If-Modified-Since</code> （资源最后修改时间）客户端发送的时候带上</li>
</ul>
<h4 id="Last-Modified和Etag的区别"><a href="#Last-Modified和Etag的区别" class="headerlink" title="Last-Modified和Etag的区别"></a>Last-Modified和Etag的区别</h4><ul>
<li><code>Etag</code>的优先级更高</li>
<li><code>Last-Modified</code> 只精准到毫秒等级<ul>
<li>资源被修改，内容不变，Etag会更加精确。</li>
</ul>
</li>
</ul>
<h4 id="业务体现-1"><a href="#业务体现-1" class="headerlink" title="业务体现"></a>业务体现</h4><p>适用于频繁更新的资源。例如列表数据，通过服务器验证确保用户获取最新的数据，同时减少不必要的数据传输。</p>
<h2 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h2><ul>
<li>强缓存不会发出请求，直接从本地拿资源</li>
<li>协商缓存会发出请求，但是服务端会返回304，再从本地拿资源</li>
</ul>
<h2 id="两者的关系"><a href="#两者的关系" class="headerlink" title="两者的关系"></a>两者的关系</h2><ul>
<li>如果<code>Cache-Contorl</code>设置的缓存过期了</li>
<li>会去查看是否有<code>Etag</code>和<code>Last-Modified</code></li>
<li>如果有的话会先去匹配</li>
</ul>
<h2 id="刷新网页对Http缓存的影响"><a href="#刷新网页对Http缓存的影响" class="headerlink" title="刷新网页对Http缓存的影响"></a>刷新网页对Http缓存的影响</h2><ul>
<li>正常操作 （就是首次进页面）强缓存有效，协商缓存有效</li>
<li>手动刷新（F5刷新）强缓存失效，协商缓存有效</li>
<li>强制刷新 （ctrl + f5）强制缓存失效，协商缓存失效</li>
</ul>
<h2 id="不同资源的缓存实践"><a href="#不同资源的缓存实践" class="headerlink" title="不同资源的缓存实践"></a>不同资源的缓存实践</h2><p>主要是根据<strong>更新频率</strong>和<strong>重要性</strong>的不同区分</p>
<ul>
<li>对于更新频率高且必须最新的资源，我们需要一个<strong>保守</strong>的缓存策略</li>
<li>对于更新频率地且内容稳定的资源，我们需要一个<strong>激进</strong>的缓存策略</li>
</ul>
<p>典型案例：</p>
<ul>
<li><code>HTML</code>文档</li>
<li>静态文件<code>JS</code>、<code>CSS</code>、<code>Fonts</code></li>
<li>媒体文件：图片、视频等。</li>
</ul>
<h4 id="HTML文档的缓存"><a href="#HTML文档的缓存" class="headerlink" title="HTML文档的缓存"></a>HTML文档的缓存</h4><p>入口文件，需要返回必须最新内容。所以需要<strong>保守</strong>的缓存策略</p>
<blockquote>
<p><code>cache-control：no-cache</code>强行协商缓存，再通过<code>ETag</code>和<code>Last-modified</code>确保最新内容返回。</p>
<ul>
<li>性能优化</li>
<li>内容新鲜</li>
</ul>
</blockquote>
<h4 id="静态文件的缓存"><a href="#静态文件的缓存" class="headerlink" title="静态文件的缓存"></a>静态文件的缓存</h4><p>内容稳定，使用<strong>激进</strong>的缓存策略。目标是实现<strong>永久缓存</strong>，只是用强缓存</p>
<ul>
<li><em>文件指纹</em>： 当url变化，浏览器就会认定这是一个全新的资源。从而强制发起请求，而不是用旧的本地资源。</li>
<li><code>cache-control：max-age：【一年】，public，immutale</code>；设置永久缓存</li>
</ul>
<p>效果：</p>
<ul>
<li>性能最大化：旧文件永不校验，新文件立即下载。</li>
<li>缓存零风险：缓存不会导致用户拿到过期资源。</li>
</ul>
<h4 id="媒体文件"><a href="#媒体文件" class="headerlink" title="媒体文件"></a>媒体文件</h4><p>更新频率不稳定，需要强缓存+协商缓存二者结合；</p>
<ul>
<li><strong>性能 (强缓存)</strong>：在短时间内，用户重复访问时不需要发起任何请求，速度最快。</li>
<li><strong>新鲜度&#x2F;带宽 (协商缓存)</strong>：一旦强缓存过期，通过轻量的 <code>304</code> 校验来确认文件是否被修改，从而避免重新下载大文件。</li>
</ul>
<p>如果使用短时长（一小时）的<code>max-age</code>，保证服务器压力和性能加速呢，我们可以：</p>
<ul>
<li>在用户上传的文件后添加一个参数，例如版本号<code>avatar.jpg?v=1234</code>，如果用户更新，我们在参数后修改即可，不会修改到文件名本身。</li>
<li>对于浏览器而言，<code>avatar.jpg?v=1234</code> 是一个<strong>全新的 URL</strong>，它会<strong>强制</strong>发起网络请求，从而下载最新的头像。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://but0nly.github.io/2023/10/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E7%BC%93%E5%AD%98/" data-id="cuidA8srIBhVfsN9ZTjehU-5H" data-title="HTTP 缓存" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-浏览器原理/跨域的解决方案" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="article-date">
  <time class="dt-published" datetime="2023-10-04T16:00:00.000Z" itemprop="datePublished">2023-10-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">跨域的解决方案</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="CORS（跨域资源共享）跨域问题解决方案"><a href="#CORS（跨域资源共享）跨域问题解决方案" class="headerlink" title="CORS（跨域资源共享）跨域问题解决方案"></a>CORS（跨域资源共享）跨域问题解决方案</h3><p>让服务端明确告诉浏览器，哪些资源可以由外部访问。</p>
<p><strong>CORS</strong>的工作原理可分为：<em>简易请求</em>和<em>预检请求</em></p>
<h5 id="简易请求"><a href="#简易请求" class="headerlink" title="简易请求"></a>简易请求</h5><p>何为建议请求：</p>
<ol>
<li>方法限制：<code>GET</code>、<code>POST</code>之一</li>
<li>Header限制：没有自定义<code>Header</code></li>
<li><code>Content-type</code>限制：只能是 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code> 或 <code>text/plain</code></li>
</ol>
<p>此时的工作流程：</p>
<ol>
<li>浏览器发出请求：浏览器像往常一样发出请求，会在<code>Header</code>中自动添加一个<code>origin</code>字段，表明当前页面的源。</li>
<li>服务端处理请求：服务端接受请求、处理数据，并准备响应。</li>
<li>服务端添加<strong>CORS</strong>响应头：在响应头中添加一个关键字段：<ul>
<li><code>Access-Control-Allow-Origin：&lt;Origin&gt;</code></li>
<li>或者<code>Access-Control-Allow-Origin</code>允许所有源访问</li>
</ul>
</li>
<li>浏览器检查：浏览器检查<code>Access-Control-Allow-Origin</code>的值<ul>
<li>如果<code>Origin</code>与之匹配，浏览器就允许JavaScript访问数据</li>
<li>如果不匹配或者缺少该字段，浏览器就会抛出<strong>跨域</strong>错误，并丢弃响应数据。</li>
</ul>
</li>
</ol>
<h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><p>不符合<em>简易请求</em>的都是<em>预检请求</em>。例如<code>PUT</code>&#x2F;<code>DELETE</code>方法的请求，或者请求中包含了自定义<code>Header</code>。</p>
<p>工作流程：</p>
<ol>
<li>浏览器发送预检请求：在发出正式请求之前，浏览器会先自动发送一个<code>OPTIONS</code>方法的请求，这个就是<em>预检</em>，<em>预检</em>请求头中携带关键信息：<ul>
<li><code>Origin</code>：实际请求的源</li>
<li><code>Access-Control-Request-Method</code>：实际请求的方法</li>
<li><code>Access-Control-Request-Headers</code>：实际请求携带的自定义<code>Header</code>列表</li>
</ul>
</li>
<li>浏览器响应<em>预检</em>“：<ul>
<li><code>Access-Control-Allow-Origin</code>：允许的源</li>
<li><code>Access-Control-Allow-Method</code>：允许的请求方法</li>
<li><code>Access-Control-Allow-Headers</code>：允许携带的自定义<code>Header</code>列表</li>
<li><code>Access-Control-Max-Age</code>：缓存时间，表示接下来多少秒内，对于同一个源，不需要再发送<em>预检</em>请求。</li>
</ul>
</li>
<li>浏览器判断<ul>
<li>如果<em>预检</em>通过，浏览器才会发送第二次，也就是实际请求，</li>
<li>如果<em>预检</em>失败，浏览器就直接抛出失败，不会发送实际请求。</li>
</ul>
</li>
</ol>
<h4 id="凭证共享"><a href="#凭证共享" class="headerlink" title="凭证共享"></a>凭证共享</h4><p>默认情况下，跨域请求不会带上<code>Cookie</code>和HTTP认证信息。如果需要携带凭证，需要在客户端和服务端同时配置<code>credentials</code>。</p>
<ul>
<li><strong>客户端 (JS)</strong>：在请求中设置 <code>credentials</code> 属性为 <code>include</code>。</li>
<li><strong>服务器端 (响应头)</strong>：必须设置：<ul>
<li><code>Access-Control-Allow-Credentials: true</code></li>
<li><strong>注意</strong>：一旦设置了 <code>Access-Control-Allow-Credentials: true</code>，则 <strong><code>Access-Control-Allow-Origin</code> 的值就不能是 <code>*</code> (星号)</strong>，必须指定具体的源，以确保安全。</li>
</ul>
</li>
</ul>
<h3 id="跨域的解决方法"><a href="#跨域的解决方法" class="headerlink" title="跨域的解决方法"></a>跨域的解决方法</h3><p>最常用最安全稳定的解决方案就是：<strong>跨域代理</strong>，其他都是已经过时或者就是不安全不稳定。</p>
<p><em><strong>跨域代理（Proxy）</strong></em><br>核心理念就是利用同源策略只限制客户端的特性。</p>
<ol>
<li>浏览器受到同源策略的原因，不能直接访问服务器B。</li>
<li>但是代理服务器A却不受同源策略的影响。</li>
</ol>
<p>所以，解决办法是：我们在客户端和服务端B之前加一个代理服务器A。用于中转数据，不受同源策略影响。主要流程：</p>
<ol>
<li>客户端向<em>代理服务器A</em>发出请求。</li>
<li><em>代理服务器A</em>收到请求后，代向<em>目标服务器B</em>发送请求。</li>
<li><em>目标服务器B</em>收到请求后，将响应结果返回给<em>代理服务器A</em></li>
<li><em>代理服务器A</em>再将响应转发给客户端。</li>
</ol>
<h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><p>分为<em>开发环境</em>和<em>生产环境</em></p>
<p><em>开发环境</em>：<br>通过前端构建工具（<code>webpack dev server</code>、<code>vite</code>、<code>create react app</code>或者<code>Vue ClI</code>等等）提供的代理功能。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js 或 webpack dev server 配置</span></span><br><span class="line">devServer<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// 告诉开发服务器，将所有以 &#x27;/api&#x27; 开头的请求代理到目标服务器</span></span><br><span class="line">  proxy<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    &#x27;/api&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      target<span class="punctuation">:</span> &#x27;http<span class="punctuation">:</span><span class="comment">//third-party-api.com&#x27;, // 目标服务器地址</span></span><br><span class="line">      changeOrigin<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 非常重要：将请求的 Host 字段改为目标服务器的 Host</span></span><br><span class="line">      pathRewrite<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        &#x27;^/api&#x27;<span class="punctuation">:</span> &#x27;&#x27; <span class="comment">// 可选：重写路径，例如将 /api/users 变为 /users</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><em>生产环境</em><br>需要使用成熟的Web服务器（<em>Niginx</em>或者<em>Apache</em>等）又或是<em>java</em>&#x2F;<em>node.js</em>等后端服务器作为反向代理。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server <span class="punctuation">&#123;</span></span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name frontend.com; # 前端域名</span><br><span class="line"></span><br><span class="line">    location /api/ <span class="punctuation">&#123;</span></span><br><span class="line">        # 将所有 /api/ 开头的请求代理到目标服务器</span><br><span class="line">        proxy_pass http<span class="punctuation">:</span><span class="comment">//target-api.com/;</span></span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    location / <span class="punctuation">&#123;</span></span><br><span class="line">        # 匹配其他路径，用于提供前端静态文件</span><br><span class="line">        root /path/to/frontend/dist;</span><br><span class="line">        index index.html;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="代理服务器的优劣势"><a href="#代理服务器的优劣势" class="headerlink" title="代理服务器的优劣势"></a>代理服务器的优劣势</h5><table>
<thead>
<tr>
<th>特性</th>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td><em>灵活性</em></td>
<td>几乎可以解决所有跨域问题。包括第三方API。</td>
<td>需要配置或维护额外的代理服务器。</td>
</tr>
<tr>
<td><em>安全性</em></td>
<td>隐藏后端服务器或第三方API的真实地址。</td>
<td>中间多了一层网络请求。略微增加延迟</td>
</tr>
<tr>
<td><em>控制权</em></td>
<td>可以对请求和响应进行拦截和修改（添加认证Header或者记录日志）</td>
<td>如果配置不恰当，可能会带来安全问题。</td>
</tr>
</tbody></table>
<h3 id="其他跨域解决方案"><a href="#其他跨域解决方案" class="headerlink" title="其他跨域解决方案"></a>其他跨域解决方案</h3><ul>
<li><code>JSONP</code>：利用<code>&lt;script&gt;</code>标签没有跨域限制的原理。</li>
<li><code>window.postMessge</code>：用于解决不同<code>iframe</code>窗口之间的通信。</li>
<li><code>WebSockets</code>：一种天然允许的全双工通信协议。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://but0nly.github.io/2023/10/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" data-id="cuidoZFVq2jEM0zI2OQaNMhFX" data-title="跨域的解决方案" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/">团队协作</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/" rel="tag">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AI/" style="font-size: 10px;">AI</a> <a href="/tags/JavaScript/" style="font-size: 17.5px;">JavaScript</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 20px;">前端</a> <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 12.5px;">工程化</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 15px;">浏览器</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 10px;">缓存</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/18/AI/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8cursor%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF/">关于我是用Cursor的一些思路</a>
          </li>
        
          <li>
            <a href="/2025/01/18/%E9%97%AE%E9%A2%98/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8IndexDB%E7%9A%84%E5%9D%91/">关于使用 IndexDB 的选型以及碰到的问题</a>
          </li>
        
          <li>
            <a href="/2024/02/13/%E6%83%B3%E6%B3%95/%E5%AE%A2%E6%88%B7%E7%AB%AF%20Mock%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">客户端 Mock 解决方案</a>
          </li>
        
          <li>
            <a href="/2023/12/11/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%9F%BA%E7%A1%80/">前端工程化基础</a>
          </li>
        
          <li>
            <a href="/2023/10/17/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B/">前端优化有哪些</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 but0nly<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>